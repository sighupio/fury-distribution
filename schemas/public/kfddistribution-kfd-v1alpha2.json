{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": ["KFDDistribution"]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": ["apiVersion", "kind", "metadata", "spec"],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": ["name"]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "minLength": 1
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "./spec-plugins.json"
        }
      },
      "required": ["distributionVersion", "distribution"]
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "kubeconfig": {
          "type": "string",
          "description": "The kubeconfig file path"
        },
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": ["modules", "kubeconfig"],
      "if": {
        "allOf": [
          {
            "required": ["common"]
          },
          {
            "properties": {
              "common": {
                "required": ["provider"]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": ["type"]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for all the KFD modules"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is registry.sighup.io/fury)."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The type of the provider"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": ["dr", "ingress", "logging", "policy"]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "the base domain used for all the KFD ingresses, if in the nginx dual configuration, it should be the same as the .spec.distribution.modules.ingress.dns.private.name zone"
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the nginx ingress controller module"
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager"
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        }
      },
      "required": ["baseDomain", "nginx"],
      "if": {
        "properties": {
          "nginx": {
            "properties": {
              "tls": {
                "properties": {
                  "provider": {
                    "const": "certManager"
                  }
                }
              }
            }
          }
        }
      },
      "then": {
        "required": ["certManager"]
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the ingress module"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the ingress module"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "single", "dual"],
          "description": "The type of the nginx ingress controller, must be ***none***, ***single*** or ***dual***"
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": ["certManager", "secret", "none"],
          "description": "The provider of the TLS certificate, must be ***none***, ***certManager*** or ***secret***"
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": ["provider"],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": ["secret"]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file content or you can use the file notation to get the content from a file"
        },
        "key": {
          "type": "string"
        },
        "ca": {
          "type": "string"
        }
      },
      "required": ["ca", "cert", "key"]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["clusterIssuer"]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster issuer"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email of the cluster issuer"
        },
        "type": {
          "type": "string",
          "enum": ["http01"],
          "description": "The type of the cluster issuer, must be ***http01***"
        },
        "solvers": {
          "type": "array",
          "description": "The custom solvers configurations"
        }
      },
      "required": ["name", "email"],
      "oneOf": [
        {
          "required": ["type"]
        },
        {
          "required": ["solvers"]
        }
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "opensearch", "loki", "customOutputs"],
          "description": "selects the logging stack. Choosing none will disable the centralized logging. Choosing opensearch will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored. Choosing loki will use a distributed Grafana Loki instead of OpenSearh for storage. Choosing customOuput the Logging Operator will be deployed and installed but with no local storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": ["opensearch"]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": ["customOutputs"]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["single", "triple"],
          "description": "The type of the opensearch, must be ***single*** or ***triple***"
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the opensearch pods"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each minio disk, 6 disks total"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username of the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password of the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the loki external endpoint"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the loki external endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the loki external endpoint"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the loki external endpoint"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the loki external endpoint"
            }
          }
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "when using the customOutputs logging type, you need to manually specify the spec of the several Output and ClusterOutputs that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "configuration for the Monitoring module components",
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "prometheus", "prometheusAgent", "mimir"],
          "description": "The type of the monitoring, must be ***none***, ***prometheus***, ***prometheusAgent*** or ***mimir***.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instace, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: wil install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, and in addition Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the K8s Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the k8s Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the k8s Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook url to send deadman switch monitoring, for example to use with healthchecks.io"
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "If true, the default rules will be installed"
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The slack webhook url to send alerts"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string"
        },
        "basicAuthIngress": {
          "type": "boolean"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the mimir pods"
        },
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"],
          "description": "The backend for the mimir pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external mimir backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external mimir backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external mimir backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external mimir backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external mimir backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "tempo"],
          "description": "The type of tracing to use, either ***none*** or ***tempo***"
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the tempo pods"
        },
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"],
          "description": "The backend for the tempo pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external tempo backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external tempo backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external tempo backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external tempo backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external tempo backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        },
        "cilium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.Cilium"
        },
        "type": {
          "type": "string",
          "enum": ["none", "calico", "cilium"],
          "description": "The type of networking to use, either ***none***, ***calico*** or ***cilium***"
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "cilium"
              }
            }
          },
          "then": {
            "required": ["cilium"]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.Cilium": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr"
        },
        "maskSize": {
          "type": "string"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["podCidr", "maskSize"]
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "gatekeeper", "kyverno"],
          "description": "The type of security to use, either ***none***, ***gatekeeper*** or ***kyverno***"
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": ["type"],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": ["gatekeeper"]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": ["kyverno"]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": ["deny", "dryrun", "warn"],
          "description": "The enforcement action to use for the gatekeeper module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["enforcementAction", "installDefaultPolicies"]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the constraints on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": ["audit", "enforce"],
          "description": "The validation failure action to use for the kyverno module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["validationFailureAction", "installDefaultPolicies"]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": ["none", "on-premises"],
          "description": "The type of the DR, must be ***none*** or ***on-premises***"
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": ["type"],
      "if": {
        "properties": {
          "type": {
            "const": "on-premises"
          }
        }
      },
      "then": {
        "required": ["type", "velero"]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for velero"
        },
        "backend": {
          "type": "string",
          "enum": ["minio", "externalEndpoint"],
          "description": "The backend for velero"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint for velero"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key for velero backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id for velero backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name for velero backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the auth module"
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        }
      },
      "required": ["provider"],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": ["dex", "pomerium", "baseDomain"]
          },
          "else": {
            "properties": {
              "dex": {
                "type": "null"
              },
              "pomerium": {
                "type": "null"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": ["basicAuth"]
              }
            }
          },
          "else": {
            "properties": {
              "provider": {
                "basicAuth": {
                  "type": "null"
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the auth module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the auth module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      },
      "required": ["host", "ingressClass"]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": ["none", "basicAuth", "sso"],
          "description": "The type of the provider, must be ***none***, ***sso*** or ***basicAuth***"
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": ["type"]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for the basic auth"
        },
        "password": {
          "type": "string",
          "description": "The password for the basic auth"
        }
      },
      "required": ["username", "password"]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "./spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "connectors": {
          "type": "array",
          "description": "The connectors for dex"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "The additional static clients for dex"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": ["connectors"]
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^([a-zA-Z0-9\\-\\.\\/]+)=(\\w+):(NoSchedule|PreferNoSchedule|NoExecute)$"
      }
    },
    "Types.KubeNodeSelector": {
      "type": ["object", "null"],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": ["NoSchedule", "PreferNoSchedule", "NoExecute"]
        },
        "operator": {
          "type": "string",
          "enum": ["Exists", "Equal"]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": ["effect", "key"],
      "anyOf": [
        {
          "required": ["operator"]
        },
        {
          "required": ["value"]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu request for the prometheus pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the opensearch pods"
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu limit for the loki pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the opensearch pods"
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the security module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the monitoring module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the minio module"
        },
        "tolerations": {
          "type": ["array", "null"],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cert-manager module"
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication"
        },
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      }
    }
  }
}
