{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A KFD Cluster deployed on top of AWS's Elastic Kubernetes Service (EKS).",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": [
        "EKSCluster"
      ]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster. It will also be used as a prefix for all the other resources created.",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": [
        "name"
      ]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "description": "Defines which KFD version will be installed and, in consequence, the Kubernetes version used to create the cluster. It supports git tags and branches. Example: `v1.30.1`.",
          "minLength": 1
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "Defines in which AWS region the cluster and all the related resources will be created."
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "This map defines which will be the common tags that will be added to all the resources created on AWS."
        },
        "toolsConfiguration": {
          "$ref": "#/$defs/Spec.ToolsConfiguration",
          "description": "Configuration for tools used by furyctl, like Terraform."
        },
        "infrastructure": {
          "$ref": "#/$defs/Spec.Infrastructure"
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "../public/spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "region",
        "kubernetes",
        "distribution",
        "toolsConfiguration"
      ],
      "if": {
        "anyOf": [
          {
            "properties": {
              "infrastructure": {
                "type": "null"
              }
            }
          },
          {
            "properties": {
              "infrastructure": {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "kubernetes": {
            "required": [
              "vpcId",
              "subnetIds"
            ]
          }
        }
      },
      "else": {
        "properties": {
          "kubernetes": {
            "type": "object",
            "properties": {
              "vpcId": {
                "type": "null"
              },
              "subnetIds": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.ToolsConfiguration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "terraform": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform"
        }
      },
      "required": [
        "terraform"
      ]
    },
    "Spec.ToolsConfiguration.Terraform": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "state": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State"
        }
      },
      "required": [
        "state"
      ]
    },
    "Spec.ToolsConfiguration.Terraform.State": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for storing the Terraform state of the cluster.",
      "properties": {
        "s3": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State.S3"
        }
      },
      "required": [
        "s3"
      ]
    },
    "Spec.ToolsConfiguration.Terraform.State.S3": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the S3 bucket used to store the Terraform state.",
      "properties": {
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "description": "This value defines which bucket will be used to store all the states."
        },
        "keyPrefix": {
          "$ref": "#/$defs/Types.AwsS3KeyPrefix",
          "description": "This value defines which folder will be used to store all the states inside the bucket."
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "This value defines in which region the bucket is located."
        },
        "skipRegionValidation": {
          "type": "boolean",
          "description": "This value defines if the region of the bucket should be validated or not by Terraform, useful when using a bucket in a recently added region."
        }
      },
      "required": [
        "bucketName",
        "keyPrefix",
        "region"
      ]
    },
    "Spec.Infrastructure": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "vpc": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc"
        },
        "vpn": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn"
        }
      },
      "allOf": [
        {
          "if": {
            "allOf": [
              {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "type": "null"
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "required": [
                  "vpcId"
                ]
              }
            }
          }
        },
        {
          "if": {
            "allOf": [
              {
                "not": {
                  "properties": {
                    "vpc": {
                      "type": "null"
                    }
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "properties": {
                        "vpcId": {
                          "type": "null"
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "properties": {
                  "vpcId": {
                    "type": "null"
                  }
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Infrastructure.Vpc": {
      "type": "object",
      "description": "Configuration for the VPC that will be created to host the EKS cluster and its related resources. If you already have a VPC that you want to use, leave this section empty and use `.spec.kubernetes.vpcId` instead.",
      "additionalProperties": false,
      "properties": {
        "network": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network"
        }
      },
      "required": [
        "network"
      ]
    },
    "Spec.Infrastructure.Vpc.Network": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The network CIDR for the VPC that will be created"
        },
        "subnetsCidrs": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network.SubnetsCidrs"
        }
      },
      "required": [
        "cidr",
        "subnetsCidrs"
      ]
    },
    "Spec.Infrastructure.Vpc.Network.SubnetsCidrs": {
      "type": "object",
      "description": "Network CIDRS configuration for private and public subnets.",
      "additionalProperties": false,
      "properties": {
        "private": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "The network CIDRs for the private subnets, where the nodes, the pods, and the private load balancers will be created"
        },
        "public": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "The network CIDRs for the public subnets, where the public load balancers and the VPN servers will be created"
        }
      },
      "required": [
        "private",
        "public"
      ]
    },
    "Spec.Infrastructure.Vpn": {
      "type": "object",
      "description": "Configuration for the VPN server instances.",
      "additionalProperties": false,
      "properties": {
        "instances": {
          "type": "integer",
          "description": "The number of VPN server instances to create, `0` to skip the creation."
        },
        "port": {
          "$ref": "#/$defs/Types.TcpPort",
          "description": "The port where each OpenVPN server will listen for connections."
        },
        "instanceType": {
          "type": "string",
          "description": "The type of the AWS EC2 instance for each VPN server. Follows AWS EC2 nomenclature. Example: `t3-micro`."
        },
        "diskSize": {
          "type": "integer",
          "description": "The size of the disk in GB for each VPN server. Example: entering `50` will create disks of 50 GB."
        },
        "operatorName": {
          "type": "string",
          "description": "The username of the account to create in the bastion's operating system."
        },
        "dhParamsBits": {
          "type": "integer",
          "description": "The `dhParamsBits` size used for the creation of the .pem file that will be used in the dh openvpn server.conf file."
        },
        "vpnClientsSubnetCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The network CIDR that will be used to assign IP addresses to the VPN clients when connected."
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn.Ssh"
        },
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "The ID of the VPC where the VPN server instances will be created, required only if `.spec.infrastructure.vpc` is omitted."
        },
        "bucketNamePrefix": {
          "$ref": "#/$defs/Types.AwsS3BucketNamePrefix",
          "description": "This value defines the prefix for the bucket name where the VPN servers will store their state (VPN certificates, users)."
        },
        "iamUserNameOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleName",
          "description": "Overrides IAM user name for the VPN. Default is to use the cluster name."
        }
      },
      "required": [
        "ssh",
        "vpnClientsSubnetCidr"
      ]
    },
    "Spec.Infrastructure.Vpn.Ssh": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "publicKeys": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/Types.SshPubKey"
              },
              {
                "$ref": "#/$defs/Types.FileRef"
              }
            ]
          },
          "description": "**NOT IN USE**, use `githubUsersName` instead. This value defines the public keys that will be added to the bastion's operating system."
        },
        "githubUsersName": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "description": "List of GitHub usernames from whom get their SSH public key and add as authorized keys of the `operatorName` user."
        },
        "allowedFromCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "The network CIDR enabled in the security group to access the VPN servers (bastions) via SSH. Setting this to `0.0.0.0/0` will allow any source."
        }
      },
      "required": [
        "allowedFromCidrs",
        "githubUsersName"
      ]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "description": "Defines the Kubernetes components configuration and the values needed for the `kubernetes` phase of furyctl.",
      "additionalProperties": false,
      "properties": {
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "Required only if `.spec.infrastructure.vpc` is omitted. This value defines the ID of the VPC where the EKS cluster and its related resources will be created."
        },
        "clusterIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default prefix for the IAM role name of the EKS cluster. If not set, a name will be generated from the cluster name."
        },
        "workersIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default prefix for the IAM role name of the EKS workers. If not set, a name will be generated from the cluster name."
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "Required only if `.spec.infrastructure.vpc` is omitted. This value defines the ID of the subnet where the EKS cluster will be created."
        },
        "apiServer": {
          "$ref": "#/$defs/Spec.Kubernetes.APIServer"
        },
        "serviceIpV4Cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "This value defines the network CIDR that will be used to assign IP addresses to Kubernetes services."
        },
        "nodeAllowedSshPublicKey": {
          "anyOf": [
            {
              "$ref": "#/$defs/Types.AwsSshPubKey"
            },
            {
              "$ref": "#/$defs/Types.FileRef"
            }
          ],
          "description": "The SSH public key that can connect to the nodes via SSH using the `ec2-user` user. Example: the contents of your `~/.ssh/id_ras.pub` file."
        },
        "nodePoolsLaunchKind": {
          "type": "string",
          "enum": [
            "launch_configurations",
            "launch_templates",
            "both"
          ],
          "description": "Accepted values are `launch_configurations`, `launch_templates` or `both`. For new clusters use `launch_templates`, for adopting an existing cluster you'll need to migrate from `launch_configurations` to `launch_templates` using `both` as interim."
        },
        "nodePoolGlobalAmiType": {
          "type": "string",
          "enum": [
            "alinux2",
            "alinux2023"
          ],
          "description": "Global default AMI type used for EKS worker nodes. This will apply to all node pools unless overridden by a specific node pool."
        },
        "logRetentionDays": {
          "type": "integer",
          "description": "Optional Kubernetes Cluster log retention in CloudWatch, expressed in days. Setting the value to zero (`0`) makes retention last forever. Default is `90` days.",
          "enum": [
            0,
            1,
            3,
            5,
            7,
            14,
            30,
            60,
            90,
            120,
            150,
            180,
            365,
            400,
            545,
            731,
            1096,
            1827,
            2192,
            2557,
            2922,
            3288,
            3653
          ]
        },
        "logsTypes": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "api",
              "audit",
              "authenticator",
              "controllerManager",
              "scheduler"
            ]
          },
          "minItems": 0,
          "description": "Optional list of Kubernetes Cluster log types to enable. Defaults to all types."
        },
        "nodePoolsCommon": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePoolsCommon"
        },
        "nodePools": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool"
          }
        },
        "awsAuth": {
          "$ref": "#/$defs/Spec.Kubernetes.AwsAuth"
        }
      },
      "required": [
        "apiServer",
        "nodeAllowedSshPublicKey",
        "nodePools",
        "nodePoolsLaunchKind",
        "nodePoolGlobalAmiType"
      ]
    },
    "Spec.Kubernetes.APIServer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "privateAccess": {
          "type": "boolean",
          "description": "This value defines if the Kubernetes API server will be accessible from the private subnets. Default it `true`."
        },
        "privateAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "The network CIDRs from the private subnets that will be allowed access the Kubernetes API server."
        },
        "publicAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "The network CIDRs from the public subnets that will be allowed access the Kubernetes API server."
        },
        "publicAccess": {
          "type": "boolean",
          "description": "This value defines if the Kubernetes API server will be accessible from the public subnets. Default is `false`."
        }
      },
      "required": [
        "privateAccess",
        "publicAccess"
      ]
    },
    "Spec.Kubernetes.NodePoolsCommon": {
      "type": "object",
      "additionalProperties": false,
      "description": "Additional properties in common for all self-managed node pools. Currently only IMDS properties are supported.",
      "properties": {
        "metadataHttpEndpoint": {
          "description": "Specifies whether the instance metadata service (IMDS) is enabled or disabled. When set to 'disabled', instance metadata is not accessible.",
          "type": "string",
          "enum": [
            "enabled",
            "disabled"
          ]
        },
        "metadataHttpTokens": {
          "description": "Defines whether the use of IMDS session tokens is required. When set to 'required', all metadata requests must include a valid session token.",
          "type": "string",
          "enum": [
            "optional",
            "required"
          ]
        },
        "metadataHttpPutResponseHopLimit": {
          "description": "Specifies the maximum number of network hops allowed for instance metadata PUT response packets. This helps control access to instance metadata across different network layers.",
          "type": "integer"
        }
      }
    },
    "Spec.Kubernetes.NodePool": {
      "type": "object",
      "additionalProperties": false,
      "description": "Array with all the node pool definitions that will join the cluster. Each item is an object.",
      "properties": {
        "type": {
          "description": "The type of Node Pool, can be `self-managed` for using customization like custom AMI, set max pods per node or `eks-managed` for using prebuilt AMIs from Amazon via the `ami.type` field. It is recommended to use `self-managed`.",
          "type": "string",
          "enum": [
            "eks-managed",
            "self-managed"
          ]
        },
        "name": {
          "type": "string",
          "description": "The name of the node pool."
        },
        "ami": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Ami"
        },
        "containerRuntime": {
          "type": "string",
          "enum": [
            "docker",
            "containerd"
          ],
          "description": "The container runtime to use in the nodes of the node pool. Default is `containerd`."
        },
        "size": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Size"
        },
        "instance": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Instance"
        },
        "attachedTargetGroups": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsArn"
          },
          "description": "This optional array defines additional target groups to attach to the instances in the node pool."
        },
        "labels": {
          "$ref": "#/$defs/Types.KubeLabels",
          "description": "Kubernetes labels that will be added to the nodes."
        },
        "taints": {
          "$ref": "#/$defs/Types.KubeTaints",
          "description": "Kubernetes taints that will be added to the nodes."
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "AWS tags that will be added to the ASG and EC2 instances."
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "Optional list of subnet IDs where to create the nodes."
        },
        "additionalFirewallRules": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRules"
        }
      },
      "required": [
        "instance",
        "name",
        "size",
        "type"
      ],
      "if": {
        "allOf": [
          {
            "properties": {
              "type": {
                "enum": [
                  "eks-managed"
                ]
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "ami": {
            "properties": {
              "id": {
                "type": "null"
              },
              "owner": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.Kubernetes.NodePool.Ami": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for customize the Amazon Machine Image (AMI) for the machines of the Node Pool.\n\nThe AMI can be chosen either by specifing the `ami.id` and `ami.owner` fields for using a custom AMI (just with `self-managed` node pool type) or by setting the `ami.type` field to one of the official AMIs based on Amazon Linux.",
      "properties": {
        "id": {
          "type": "string",
          "description": "The ID of the AMI to use for the nodes, must be set toghether with the `owner` field. `ami.id` and `ami.owner` can be only set when Node Pool type is `self-managed` and they can't be set at the same time than `ami.type`."
        },
        "owner": {
          "type": "string",
          "description": "The owner of the AMI to use for the nodes, must be set toghether with the `id` field. `ami.id` and `ami.owner` can be only set when Node Pool type is `self-managed` and they can't be set at the same time than `ami.type`."
        },
        "type": {
          "type": "string",
          "description": "The AMI type defines the AMI to use for `eks-managed` and `self-managed` type of Node Pools. Only Amazon Linux based AMIs are supported. It can't be set at the same time than `ami.id` and `ami.owner`.",
          "enum": [
            "alinux2",
            "alinux2023"
          ]
        }
      },
      "oneOf": [
        {
          "allOf": [
            {
              "required": [
                "id",
                "owner"
              ]
            },
            {
              "not": {
                "required": [
                  "type"
                ]
              }
            }
          ]
        },
        {
          "allOf": [
            {
              "required": [
                "type"
              ]
            },
            {
              "not": {
                "anyOf": [
                  {
                    "required": [
                      "id"
                    ]
                  },
                  {
                    "required": [
                      "owner"
                    ]
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    "Spec.Kubernetes.NodePool.Instance": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the instances that will be used in the node pool.",
      "properties": {
        "type": {
          "type": "string",
          "description": "The instance type to use for the nodes."
        },
        "spot": {
          "type": "boolean",
          "description": "If `true`, the nodes will be created as spot instances. Default is `false`."
        },
        "volumeSize": {
          "type": "integer",
          "description": "The size of the disk in GB."
        },
        "volumeType": {
          "type": "string",
          "description": "Volume type for the instance disk. Default is `gp2`.",
          "enum": [
            "gp2",
            "gp3",
            "io1",
            "standard"
          ]
        },
        "maxPods": {
          "type": "integer",
          "description": "Set the maximum pods per node to a custom value. If not set will use EKS default value that depends on the instance type.\n\nRef: https://github.com/awslabs/amazon-eks-ami/blob/main/templates/shared/runtime/eni-max-pods.txt"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.Size": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "min": {
          "type": "integer",
          "minimum": 0,
          "description": "The minimum number of nodes in the node pool."
        },
        "max": {
          "type": "integer",
          "minimum": 0,
          "description": "The maximum number of nodes in the node pool."
        }
      },
      "required": [
        "max",
        "min"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRules": {
      "type": "object",
      "additionalProperties": false,
      "description": "Optional additional firewall rules that will be attached to the nodes.",
      "properties": {
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock"
          },
          "minItems": 1,
          "description": "The CIDR blocks objects definition for the Firewall rule."
        },
        "sourceSecurityGroupId": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId"
          },
          "minItems": 1,
          "description": "The Source Security Group ID objects definition for the Firewall rule."
        },
        "self": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self"
          },
          "minItems": 1,
          "description": "The `self` objects definition for the Firewall rule."
        }
      }
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "description": "The type of the Firewall rule, can be `ingress` for incoming traffic or `egress` for outgoing traffic.",
          "enum": [
            "ingress",
            "egress"
          ]
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "Additional AWS tags for the Firewall rule."
        },
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 1
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "cidrBlocks",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name for the additional Firewall rule Security Group."
        },
        "type": {
          "type": "string",
          "enum": [
            "ingress",
            "egress"
          ],
          "description": "The type of the Firewall rule, can be `ingress` for incoming traffic or `egress` for outgoing traffic."
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "Additional AWS tags for the Firewall rule."
        },
        "sourceSecurityGroupId": {
          "type": "string",
          "description": "The source security group ID."
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the Firewall rule."
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "sourceSecurityGroupId",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the Firewall rule."
        },
        "type": {
          "type": "string",
          "enum": [
            "ingress",
            "egress"
          ],
          "description": "The type of the Firewall rule, can be `ingress` for incoming traffic or `egress` for outgoing traffic."
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "Additional AWS tags for the Firewall rule."
        },
        "self": {
          "type": "boolean",
          "description": "If `true`, the source will be the security group itself."
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the Firewall rule."
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "self",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports": {
      "type": "object",
      "description": "Port range for the Firewall Rule.",
      "additionalProperties": false,
      "properties": {
        "from": {
          "$ref": "#/$defs/Types.TcpPort"
        },
        "to": {
          "$ref": "#/$defs/Types.TcpPort"
        }
      },
      "required": [
        "from",
        "to"
      ]
    },
    "Spec.Kubernetes.AwsAuth": {
      "type": "object",
      "description": "Optional additional security configuration for EKS IAM via the `aws-auth` configmap.\n\nRef: https://docs.aws.amazon.com/eks/latest/userguide/auth-configmap.html",
      "additionalProperties": false,
      "properties": {
        "additionalAccounts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This optional array defines additional AWS accounts that will be added to the `aws-auth` configmap."
        },
        "users": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.User"
          },
          "description": "This optional array defines additional IAM users that will be added to the `aws-auth` configmap."
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.Role"
          },
          "description": "This optional array defines additional IAM roles that will be added to the `aws-auth` configmap."
        }
      }
    },
    "Spec.Kubernetes.AwsAuth.Role": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rolearn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": [
        "groups",
        "rolearn",
        "username"
      ]
    },
    "Spec.Kubernetes.AwsAuth.User": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "userarn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": [
        "groups",
        "userarn",
        "username"
      ]
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": [
        "modules"
      ],
      "if": {
        "allOf": [
          {
            "required": [
              "common"
            ]
          },
          {
            "properties": {
              "common": {
                "required": [
                  "provider"
                ]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": [
                      "type"
                    ]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "modules": {
            "required": [
              "aws"
            ]
          }
        }
      },
      "else": {
        "properties": {
          "modules": {
            "properties": {
              "aws": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "description": "Common configuration for all the distribution modules.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules. Follows Kubernetes selector format. Example: `node.kubernetes.io/role: infra`."
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "An array with the tolerations that will be added to the pods for all the KFD modules. Follows Kubernetes tolerations format. Example:\n\n```yaml\n- effect: NoSchedule\n  key: node.kubernetes.io/role\n  value: infra\n```"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed."
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is `registry.sighup.io/fury`).\n\nNOTE: If plugins are pulling from the default registry, the registry will be replaced for the plugin too."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The provider type. Don't set. FOR INTERNAL USE ONLY."
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "aws": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Aws"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": [
        "dr",
        "ingress",
        "logging",
        "policy"
      ]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain used for all the KFD infrastructural ingresses. If in the nginx `dual` configuration type, this value should be the same as the `.spec.distribution.modules.ingress.dns.private.name` zone."
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the Ingress nginx controller package."
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager",
          "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses."
        },
        "dns": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS"
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        }
      },
      "required": [
        "baseDomain",
        "nginx"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "type": {
                    "const": "dual"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dns"
            ],
            "properties": {
              "dns": {
                "required": [
                  "public",
                  "private"
                ]
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "type": {
                    "const": "single"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dns"
            ],
            "properties": {
              "dns": {
                "required": [
                  "public"
                ]
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "tls": {
                    "properties": {
                      "provider": {
                        "const": "certManager"
                      }
                    }
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "certManager"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Ingress module.",
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Ingress module."
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Ingress module."
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "single",
            "dual"
          ],
          "description": "The type of the Ingress nginx controller, options are:\n- `none`: no ingress controller will be installed and no infrastructural ingresses will be created.\n- `single`: a single ingress controller with ingress class `nginx` will be installed to manage all the ingress resources, infrastructural ingresses will be created.\n- `dual`: two independent ingress controllers will be installed, one for the `internal` ingress class intended for private ingresses and one for the `external` ingress class intended for public ingresses. KFD infrastructural ingresses wil use the `internal` ingress class when using the dual type.\n\nDefault is `single`."
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": [
            "certManager",
            "secret",
            "none"
          ],
          "description": "The provider of the TLS certificates for the ingresses, one of: `none`, `certManager`, or `secret`."
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": [
        "provider"
      ],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": [
          "secret"
        ]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "description": "Kubernetes TLS secret for the ingresses TLS certificate.",
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "key": {
          "type": "string",
          "description": "The signing key file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "ca": {
          "type": "string",
          "description": "The Certificate Authority certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        }
      },
      "required": [
        "ca",
        "cert",
        "key"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses.",
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "clusterIssuer"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager's ACME clusterIssuer used to request certificates from Let's Encrypt.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the clusterIssuer."
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email address to use during the certificate issuing process."
        },
        "type": {
          "type": "string",
          "enum": [
            "dns01",
            "http01"
          ],
          "description": "The type of the clusterIssuer, must be `dns01` for using DNS challenge or `http01` for using HTTP challenge."
        },
        "solvers": {
          "type": "array",
          "description": "The list of challenge solvers to use instead of the default one for the `http01` challenge. Check [cert manager's documentation](https://cert-manager.io/docs/configuration/acme/#adding-multiple-solver-types) for examples for this field."
        }
      },
      "required": [
        "name",
        "email"
      ],
      "oneOf": [
        {
          "required": [
            "type"
          ]
        },
        {
          "required": [
            "solvers"
          ]
        }
      ]
    },
    "Spec.Distribution.Modules.Ingress.DNS": {
      "type": "object",
      "description": "DNS definition, used in conjunction with `externalDNS` package to automate DNS management and certificates emission.",
      "additionalProperties": false,
      "properties": {
        "public": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Public"
        },
        "private": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Private"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.DNS.Public": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the public hosted zone."
        },
        "create": {
          "type": "boolean",
          "description": "By default, a Terraform data source will be used to get the public DNS zone. Set to `true` to create the public zone instead."
        }
      },
      "required": [
        "name",
        "create"
      ]
    },
    "Spec.Distribution.Modules.Ingress.DNS.Private": {
      "type": "object",
      "description": "The private DNS zone is used only when `ingress.nginx.type` is `dual`, for exposing infrastructural services only in the private DNS zone.",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the private hosted zone. Example: `internal.fury-demo.sighup.io`."
        },
        "create": {
          "type": "boolean",
          "description": "By default, a Terraform data source will be used to get the private DNS zone. Set to `true` to create the private zone instead."
        }
      },
      "required": [
        "name",
        "create"
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "opensearch",
            "loki",
            "customOutputs"
          ],
          "description": "Selects the logging stack. Options are:\n- `none`: will disable the centralized logging.\n- `opensearch`: will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored.\n- `loki`: will use a distributed Grafana Loki instead of OpenSearch for storage.\n- `customOuputs`: the Logging Operator will be deployed and installed but without in-cluster storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage.\n\nDefault is `opensearch`."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": [
              "opensearch"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "loki"
              }
            }
          },
          "then": {
            "required": [
              "loki"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": [
              "customOutputs"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "single",
            "triple"
          ],
          "description": "The type of OpenSearch deployment. One of: `single` for a single replica or `triple` for an HA 3-replicas deployment."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the OpenSearch volumes. Follows Kubernetes resources storage requests. Default is `150Gi`."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "description": "DEPRECATED since KFD v1.26.6, 1.27.5, v1.28.0.",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for Logging's MinIO deployment.",
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "description": "Configuration for the Loki package.",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "description": "The storage backend type for Loki. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external object storage instead of deploying an in-cluster MinIO.",
          "enum": [
            "minio",
            "externalEndpoint"
          ]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Loki's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Loki's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "tsdbStartDate": {
          "type": "string",
          "format": "date",
          "description": "Starting from versions 1.28.4, 1.29.5 and 1.30.0 of KFD, Loki will change the time series database from BoltDB to TSDB and the schema from v11 to v13 that it uses to store the logs.\n\nThe value of this field will determine the date when Loki will start writing using the new TSDB and the schema v13, always at midnight UTC. The old BoltDB and schema will be kept until they expire for reading purposes.\n\nValue must be a string in `ISO 8601` date format (`yyyy-mm-dd`). Example: `2024-11-18`."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      },
      "required": [
        "tsdbStartDate"
      ]
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging Operator.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "When using the `customOutputs` logging type, you need to manually specify the spec of the several `Output` and `ClusterOutputs` that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from the `audit` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from the `events` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from the `infra` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from the `ingressNginx` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from the `kubernetes` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from the `systemdCommon` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from the `systemdEtcd` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from the `errors` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Monitoring module.",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "prometheus",
            "prometheusAgent",
            "mimir"
          ],
          "description": "The type of the monitoring, must be `none`, `prometheus`, `prometheusAgent` or `mimir`.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instance, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: will install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, plus Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage.\n\nDefault is `prometheus`."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the `k8s` Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the `k8s` Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the `k8s` Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook URL to send dead man's switch monitoring, for example to use with healthchecks.io."
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "Set to false to avoid installing the Prometheus rules (alerts) included with the distribution."
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The Slack webhook URL where to send the infrastructural and workload alerts to."
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string",
          "description": "[JMESPath](http://jmespath.org/examples.html) expression to retrieve the user's role. Example:\n\n```yaml\nusersRoleAttributePath: \"contains(groups[*], 'beta') && 'Admin' || contains(groups[*], 'gamma') && 'Editor' || contains(groups[*], 'delta') && 'Viewer'\n```\n\nMore details in [Grafana's documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/generic-oauth/#configure-role-mapping)."
        },
        "basicAuthIngress": {
          "type": "boolean",
          "description": "Setting this to true will deploy an additional `grafana-basic-auth` ingress protected with Grafana's basic auth instead of SSO. It's intended use is as a temporary ingress for when there are problems with the SSO login flow.\n\nNotice that by default anonymous access is enabled."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Mimir package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the logs stored in Mimir. Default is `30d`. Value must match the regular expression `[0-9]+(ns|us|µs|ms|s|m|h|d|w|y)` where y = 365 days."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Mimir. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Mimir's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The external S3-compatible endpoint for Mimir's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "description": "Configuration for Monitoring's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tracing module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "tempo"
          ],
          "description": "The type of tracing to use, either `none` or `tempo`. `none` will disable the Tracing module and `tempo` will install a Grafana Tempo deployment.\n\nDefault is `tempo`."
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tempo package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the traces stored in Tempo."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Tempo. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "description": "Configuration for Tempo's external storage backend.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The external S3-compatible endpoint for Tempo's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "description": "Configuration for Tracing's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Networking module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Policy module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "gatekeeper",
            "kyverno"
          ],
          "description": "The type of policy enforcement to use, either `none`, `gatekeeper` or `kyverno`.\n\nDefault is `none`."
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": [
              "gatekeeper"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": [
              "kyverno"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Gatekeeper package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": [
            "deny",
            "dryrun",
            "warn"
          ],
          "description": "The default enforcement action to use for the included constraints. `deny` will block the admission when violations to the policies are found, `warn` will show a message to the user but will admit the violating requests and `dryrun` won't give any feedback to the user but it will log the violations."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Gatekeeper policies (constraints templates and constraints) included with the distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "enforcementAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Kyverno package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the policies on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": [
            "Audit",
            "Enforce"
          ],
          "description": "The validation failure action to use for the included policies, `Enforce` will block when a request does not comply with the policies and `Audit` will not block but log when a request does not comply with the policies."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Kyverno policies included with distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "validationFailureAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Disaster Recovery module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "eks"
          ],
          "description": "The type of the Disaster Recovery, must be `none` or `eks`. `none` disables the module and `eks` will install Velero  and use an S3 bucket to store the backups.\n\nDefault is `none`."
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": [
        "type"
      ],
      "if": {
        "properties": {
          "type": {
            "const": "eks"
          }
        }
      },
      "then": {
        "required": [
          "type",
          "velero"
        ]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "schedules": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Velero's backup schedules.",
          "properties": {
            "install": {
              "type": "boolean",
              "description": "Whether to install or not the default `manifests` and `full` backups schedules. Default is `true`."
            },
            "definitions": {
              "type": "object",
              "additionalProperties": false,
              "description": "Configuration for Velero schedules.",
              "properties": {
                "manifests": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `manifests` backup schedule (default `*/15 * * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    }
                  }
                },
                "full": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `full` backup schedule (default `0 1 * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    },
                    "snapshotMoveData": {
                      "type": "boolean",
                      "description": "EXPERIMENTAL (if you do more than one backups, the following backups after the first are not automatically restorable, see https://github.com/vmware-tanzu/velero/issues/7057#issuecomment-2466815898 for the manual restore solution): SnapshotMoveData specifies whether snapshot data should be moved. Velero will create a new volume from the snapshot and upload the content to the storageLocation."
                    }
                  }
                }
              }
            }
          }
        },
        "eks": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero.Eks"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "eks"
      ]
    },
    "Spec.Distribution.Modules.Dr.Velero.Eks": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "The region where the bucket for Velero will be located."
        },
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "maxLength": 49,
          "description": "The name of the bucket for Velero."
        }
      },
      "required": [
        "region",
        "bucketName"
      ]
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Auth module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the ingresses created by the Auth module (Gangplank, Pomerium, Dex). Notice that when the ingress module type is `dual`, these will use the `external` ingress class."
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        }
      },
      "required": [
        "provider"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dex",
              "pomerium",
              "baseDomain"
            ]
          },
          "else": {
            "properties": {
              "dex": {
                "type": "null"
              },
              "pomerium": {
                "type": "null"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": [
                  "basicAuth"
                ]
              }
            }
          },
          "else": {
            "properties": {
              "provider": {
                "basicAuth": {
                  "type": "null"
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Auth module.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Auth module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Auth module."
        },
        "ingresses": {
          "type": "object",
          "description": "Override the definition of the Auth module ingresses.",
          "additionalProperties": {
            "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      },
      "required": [
        "host",
        "ingressClass"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "basicAuth",
            "sso"
          ],
          "description": "The type of the Auth provider, options are:\n- `none`: will disable authentication in the infrastructural ingresses.\n- `sso`: will protect the infrastructural ingresses with Pomerium and Dex (SSO) and require authentication before accessing them.\n- `basicAuth`: will protect the infrastructural ingresses with HTTP basic auth (username and password) authentication.\n\nDefault is `none`."
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the HTTP Basic Auth provider.",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for logging in with the HTTP basic authentication."
        },
        "password": {
          "type": "string",
          "description": "The password for logging in with the HTTP basic authentication."
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "../public/spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Dex package.",
      "properties": {
        "connectors": {
          "type": "array",
          "description": "A list with each item defining a Dex connector. Follows Dex connectors configuration format: https://dexidp.io/docs/connectors/"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "Additional static clients defitions that will be added to the default clients included with the distribution in Dex's configuration. Example:\n\n```yaml\nadditionalStaticClients:\n  - id: my-custom-client\n    name: \"A custom additional static client\"\n    redirectURIs:\n      - \"https://myapp.tld/redirect\"\n      - \"https://alias.tld/oidc-callback\"\n    secret: supersecretpassword\n```\nReference: https://dexidp.io/docs/connectors/local/"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "connectors"
      ]
    },
    "Spec.Distribution.Modules.Aws": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterAutoscaler": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsCsiDriver": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "loadBalancerController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsSnapshotController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        }
      }
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.AwsArn": {
      "type": "string",
      "pattern": "^arn:(?P<Partition>[^:\\n]*):(?P<Service>[^:\\n]*):(?P<Region>[^:\\n]*):(?P<AccountID>[^:\\n]*):(?P<Ignore>(?P<ResourceType>[^:\\/\\n]*)[:\\/])?(?P<Resource>.*)$"
    },
    "Types.AwsRegion": {
      "type": "string",
      "enum": [
        "af-south-1",
        "ap-east-1",
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-northeast-3",
        "ap-south-1",
        "ap-south-2",
        "ap-southeast-1",
        "ap-southeast-2",
        "ap-southeast-3",
        "ap-southeast-4",
        "ca-central-1",
        "eu-central-1",
        "eu-central-2",
        "eu-north-1",
        "eu-south-1",
        "eu-south-2",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "me-central-1",
        "me-south-1",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-gov-east-1",
        "us-gov-west-1",
        "us-west-1",
        "us-west-2"
      ]
    },
    "Types.AwsVpcId": {
      "type": "string",
      "pattern": "^vpc\\-([0-9a-f]{8}|[0-9a-f]{17})$"
    },
    "Types.AwsSshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(ed25519|rsa)\\s+"
    },
    "Types.AwsSubnetId": {
      "type": "string",
      "pattern": "^subnet\\-[0-9a-f]{17}$"
    },
    "Types.AwsTags": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.AwsIpProtocol": {
      "type": "string",
      "pattern": "^(?i)(tcp|udp|icmp|icmpv6|-1)$",
      "$comment": "this value should be lowercase, but we rely on terraform to do the conversion to make it a bit more user friendly"
    },
    "Types.AwsIamRoleNamePrefix": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,38}$"
    },
    "Types.AwsIamRoleName": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,63}$"
    },
    "Types.AwsS3BucketName": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,61}[a-z0-9]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3BucketNamePrefix": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,35}[a-z0-9-.]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3KeyPrefix": {
      "type": "string",
      "pattern": "^[A-z0-9][A-z0-9!-_.*'()]+$",
      "maxLength": 960
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^([a-zA-Z0-9\\-\\.\\/]+)=([^-][\\w-]+):(NoSchedule|PreferNoSchedule|NoExecute)$"
      }
    },
    "Types.KubeNodeSelector": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "Exists",
            "Equal"
          ]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": [
        "effect",
        "key"
      ],
      "anyOf": [
        {
          "required": [
            "operator"
          ]
        },
        {
          "required": [
            "value"
          ]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The CPU request for the Pod, in cores. Example: `500m`."
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the Pod. Example: `500M`."
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The CPU limit for the Pod. Example: `1000m`."
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the Pod. Example: `1G`."
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "description": "Override the common configuration with a particular configuration for the module.",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the module."
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the package."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the package."
        }
      }
    },
    "Types.FuryModuleComponentOverridesWithIAMRoleName": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the load balancer controller module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cluster autoscaler module."
        },
        "iamRoleName": {
          "$ref": "#/$defs/Types.AwsIamRoleName"
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication even if `.spec.modules.auth.provider.type` is SSO or Basic Auth."
        },
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      }
    }
  }
}