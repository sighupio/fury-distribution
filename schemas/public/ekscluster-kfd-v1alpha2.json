{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A Fury Cluster deployed through AWS's Elastic Kubernetes Service",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": [
        "EKSCluster"
      ]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": [
        "name"
      ]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "minLength": 1
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "This map defines which will be the common tags that will be added to all the resources created on AWS."
        },
        "toolsConfiguration": {
          "$ref": "#/$defs/Spec.ToolsConfiguration"
        },
        "infrastructure": {
          "$ref": "#/$defs/Spec.Infrastructure"
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "../public/spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "region",
        "kubernetes",
        "distribution",
        "toolsConfiguration"
      ],
      "if": {
        "anyOf": [
          {
            "properties": {
              "infrastructure": {
                "type": "null"
              }
            }
          },
          {
            "properties": {
              "infrastructure": {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "kubernetes": {
            "required": [
              "vpcId",
              "subnetIds"
            ]
          }
        }
      },
      "else": {
        "properties": {
          "kubernetes": {
            "type": "object",
            "properties": {
              "vpcId": {
                "type": "null"
              },
              "subnetIds": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.ToolsConfiguration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "terraform": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform"
        }
      },
      "required": [
        "terraform"
      ]
    },
    "Spec.ToolsConfiguration.Terraform": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "state": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State"
        }
      },
      "required": [
        "state"
      ]
    },
    "Spec.ToolsConfiguration.Terraform.State": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "s3": {
          "$ref": "#/$defs/Spec.ToolsConfiguration.Terraform.State.S3"
        }
      },
      "required": [
        "s3"
      ]
    },
    "Spec.ToolsConfiguration.Terraform.State.S3": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "description": "This value defines which bucket will be used to store all the states"
        },
        "keyPrefix": {
          "$ref": "#/$defs/Types.AwsS3KeyPrefix",
          "description": "This value defines which folder will be used to store all the states inside the bucket"
        },
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "This value defines in which region the bucket is located"
        },
        "skipRegionValidation": {
          "type": "boolean",
          "description": "This value defines if the region of the bucket should be validated or not by Terraform, useful when using a bucket in a recently added region"
        }
      },
      "required": [
        "bucketName",
        "keyPrefix",
        "region"
      ]
    },
    "Spec.Infrastructure": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "vpc": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc",
          "description": "This key defines the VPC that will be created in AWS"
        },
        "vpn": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn",
          "description": "This section defines the creation of VPN bastions"
        }
      },
      "allOf": [
        {
          "if": {
            "allOf": [
              {
                "properties": {
                  "vpc": {
                    "type": "null"
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "type": "null"
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "required": [
                  "vpcId"
                ]
              }
            }
          }
        },
        {
          "if": {
            "allOf": [
              {
                "not": {
                  "properties": {
                    "vpc": {
                      "type": "null"
                    }
                  }
                }
              },
              {
                "not": {
                  "properties": {
                    "vpn": {
                      "properties": {
                        "vpcId": {
                          "type": "null"
                        }
                      }
                    }
                  }
                }
              }
            ]
          },
          "then": {
            "properties": {
              "vpn": {
                "properties": {
                  "vpcId": {
                    "type": "null"
                  }
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Infrastructure.Vpc": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "network": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network"
        }
      },
      "required": [
        "network"
      ]
    },
    "Spec.Infrastructure.Vpc.Network": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "This is the CIDR of the VPC that will be created"
        },
        "subnetsCidrs": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpc.Network.SubnetsCidrs"
        }
      },
      "required": [
        "cidr",
        "subnetsCidrs"
      ]
    },
    "Spec.Infrastructure.Vpc.Network.SubnetsCidrs": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "private": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "These are the CIRDs for the private subnets, where the nodes, the pods, and the private load balancers will be created"
        },
        "public": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "These are the CIDRs for the public subnets, where the public load balancers and the VPN servers will be created"
        }
      },
      "required": [
        "private",
        "public"
      ]
    },
    "Spec.Infrastructure.Vpn": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "instances": {
          "type": "integer",
          "description": "The number of instances to create, 0 to skip the creation"
        },
        "port": {
          "$ref": "#/$defs/Types.TcpPort",
          "description": "The port used by the OpenVPN server"
        },
        "instanceType": {
          "type": "string",
          "description": "The size of the AWS EC2 instance"
        },
        "diskSize": {
          "type": "integer",
          "description": "The size of the disk in GB"
        },
        "operatorName": {
          "type": "string",
          "description": "The username of the account to create in the bastion's operating system"
        },
        "dhParamsBits": {
          "type": "integer",
          "description": "The dhParamsBits size used for the creation of the .pem file that will be used in the dh openvpn server.conf file"
        },
        "vpnClientsSubnetCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The CIDR that will be used to assign IP addresses to the VPN clients when connected"
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Infrastructure.Vpn.Ssh"
        },
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "The VPC ID where the VPN servers will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "bucketNamePrefix": {
          "$ref": "#/$defs/Types.AwsS3BucketNamePrefix",
          "description": "This value defines the prefix that will be used to create the bucket name where the VPN servers will store the states"
        },
        "iamUserNameOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleName",
          "description": "Overrides the default IAM user name for the VPN"
        }
      },
      "required": [
        "ssh",
        "vpnClientsSubnetCidr"
      ]
    },
    "Spec.Infrastructure.Vpn.Ssh": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "publicKeys": {
          "type": "array",
          "items": {
            "anyOf": [
              {
                "$ref": "#/$defs/Types.SshPubKey"
              },
              {
                "$ref": "#/$defs/Types.FileRef"
              }
            ]
          },
          "description": "This value defines the public keys that will be added to the bastion's operating system NOTES: Not yet implemented"
        },
        "githubUsersName": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "minItems": 1,
          "description": "The github user name list that will be used to get the ssh public key that will be added as authorized key to the operatorName user"
        },
        "allowedFromCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "description": "The CIDR enabled in the security group that can access the bastions in SSH"
        }
      },
      "required": [
        "allowedFromCidrs",
        "githubUsersName"
      ]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "vpcId": {
          "$ref": "#/$defs/Types.AwsVpcId",
          "description": "This value defines the VPC ID where the EKS cluster will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "clusterIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default IAM role name prefix for the EKS cluster"
        },
        "workersIAMRoleNamePrefixOverride": {
          "$ref": "#/$defs/Types.AwsIamRoleNamePrefix",
          "description": "Overrides the default IAM role name prefix for the EKS workers"
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "This value defines the subnet IDs where the EKS cluster will be created, required only if .spec.infrastructure.vpc is omitted"
        },
        "apiServer": {
          "$ref": "#/$defs/Spec.Kubernetes.APIServer"
        },
        "serviceIpV4Cidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "This value defines the CIDR that will be used to assign IP addresses to the services"
        },
        "nodeAllowedSshPublicKey": {
          "anyOf": [
            {
              "$ref": "#/$defs/Types.AwsSshPubKey"
            },
            {
              "$ref": "#/$defs/Types.FileRef"
            }
          ],
          "description": "This key contains the ssh public key that can connect to the nodes via SSH using the ec2-user user"
        },
        "nodePoolsLaunchKind": {
          "type": "string",
          "enum": [
            "launch_configurations",
            "launch_templates",
            "both"
          ],
          "description": "Either `launch_configurations`, `launch_templates` or `both`. For new clusters use `launch_templates`, for existing cluster you'll need to migrate from `launch_configurations` to `launch_templates` using `both` as interim."
        },
        "nodePoolGlobalAmiType": {
          "type": "string",
          "enum": [
            "alinux2",
            "alinux2023"
          ],
          "description": "Global default AMI type used for EKS worker nodes. This will apply to all node pools unless overridden by a specific node pool."
        },
        "logRetentionDays": {
          "type": "integer",
          "description": "Optional Kubernetes Cluster log retention in days. Defaults to 90 days."
        },
        "logsTypes": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": [
              "api",
              "audit",
              "authenticator",
              "controllerManager",
              "scheduler"
            ]
          },
          "minItems": 0,
          "description": "Optional list of Kubernetes Cluster log types to enable. Defaults to all types."
        },
        "nodePools": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool"
          }
        },
        "awsAuth": {
          "$ref": "#/$defs/Spec.Kubernetes.AwsAuth"
        }
      },
      "required": [
        "apiServer",
        "nodeAllowedSshPublicKey",
        "nodePools",
        "nodePoolsLaunchKind"
      ]
    },
    "Spec.Kubernetes.APIServer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "privateAccess": {
          "type": "boolean",
          "description": "This value defines if the API server will be accessible only from the private subnets"
        },
        "privateAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "This value defines the CIDRs that will be allowed to access the API server from the private subnets"
        },
        "publicAccessCidrs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 0,
          "description": "This value defines the CIDRs that will be allowed to access the API server from the public subnets"
        },
        "publicAccess": {
          "type": "boolean",
          "description": "This value defines if the API server will be accessible from the public subnets"
        }
      },
      "required": [
        "privateAccess",
        "publicAccess"
      ]
    },
    "Spec.Kubernetes.NodePool": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "eks-managed",
            "self-managed"
          ]
        },
        "name": {
          "type": "string",
          "description": "The name of the node pool"
        },
        "ami": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Ami"
        },
        "containerRuntime": {
          "type": "string",
          "enum": [
            "docker",
            "containerd"
          ],
          "description": "The container runtime to use for the nodes"
        },
        "size": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Size"
        },
        "instance": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.Instance"
        },
        "attachedTargetGroups": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsArn"
          },
          "description": "This optional array defines additional target groups to attach to the instances in the node pool"
        },
        "labels": {
          "$ref": "#/$defs/Types.KubeLabels",
          "description": "Kubernetes labels that will be added to the nodes"
        },
        "taints": {
          "$ref": "#/$defs/Types.KubeTaints",
          "description": "Kubernetes taints that will be added to the nodes"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "AWS tags that will be added to the ASG and EC2 instances"
        },
        "subnetIds": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.AwsSubnetId"
          },
          "description": "This value defines the subnet IDs where the nodes will be created"
        },
        "additionalFirewallRules": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRules"
        }
      },
      "required": [
        "instance",
        "name",
        "size",
        "type"
      ],
      "if": {
        "allOf": [
          {
            "properties": {
              "type": {
                "enum": [
                  "eks-managed"
                ]
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "ami": {
            "properties": {
              "id": {
                "type": "null"
              },
              "owner": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.Kubernetes.NodePool.Ami": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "id": {
          "type": "string",
          "description": "The AMI ID to use for the nodes"
        },
        "owner": {
          "type": "string",
          "description": "The owner of the AMI"
        },
        "type": {
          "type": "string",
          "description": "The AMI type based on OS",
          "enum": [
            "alinux2",
            "alinux2023"
          ]
        }
      },
      "dependencies": {
        "id": [
          "owner"
        ]
      },
      "required": []
    },
    "Spec.Kubernetes.NodePool.Instance": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The instance type to use for the nodes"
        },
        "spot": {
          "type": "boolean",
          "description": "If true, the nodes will be created as spot instances"
        },
        "volumeSize": {
          "type": "integer",
          "description": "The size of the disk in GB"
        },
        "volumeType": {
          "type": "string",
          "enum": [
            "gp2",
            "gp3",
            "io1",
            "standard"
          ]
        },
        "maxPods": {
          "type": "integer"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.Size": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "min": {
          "type": "integer",
          "minimum": 0,
          "description": "The minimum number of nodes in the node pool"
        },
        "max": {
          "type": "integer",
          "minimum": 0,
          "description": "The maximum number of nodes in the node pool"
        }
      },
      "required": [
        "max",
        "min"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock"
          },
          "minItems": 1,
          "description": "The CIDR blocks for the FW rule. At the moment the first item of the list will be used, others will be ignored."
        },
        "sourceSecurityGroupId": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId"
          },
          "minItems": 1
        },
        "self": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self"
          },
          "minItems": 1
        }
      }
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.CidrBlock": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": [
            "ingress",
            "egress"
          ]
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags"
        },
        "cidrBlocks": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.Cidr"
          },
          "minItems": 1
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "cidrBlocks",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.SourceSecurityGroupId": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the FW rule"
        },
        "type": {
          "type": "string",
          "enum": [
            "ingress",
            "egress"
          ],
          "description": "The type of the FW rule can be ingress or egress"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "The tags of the FW rule"
        },
        "sourceSecurityGroupId": {
          "type": "string",
          "description": "The source security group ID"
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the FW rule"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "sourceSecurityGroupId",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Self": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the FW rule"
        },
        "type": {
          "type": "string",
          "enum": [
            "ingress",
            "egress"
          ],
          "description": "The type of the FW rule can be ingress or egress"
        },
        "tags": {
          "$ref": "#/$defs/Types.AwsTags",
          "description": "The tags of the FW rule"
        },
        "self": {
          "type": "boolean",
          "description": "If true, the source will be the security group itself"
        },
        "protocol": {
          "$ref": "#/$defs/Types.AwsIpProtocol",
          "description": "The protocol of the FW rule"
        },
        "ports": {
          "$ref": "#/$defs/Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports"
        }
      },
      "required": [
        "self",
        "name",
        "ports",
        "protocol",
        "type"
      ]
    },
    "Spec.Kubernetes.NodePool.AdditionalFirewallRule.Ports": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "from": {
          "$ref": "#/$defs/Types.TcpPort"
        },
        "to": {
          "$ref": "#/$defs/Types.TcpPort"
        }
      },
      "required": [
        "from",
        "to"
      ]
    },
    "Spec.Kubernetes.AwsAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalAccounts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This optional array defines additional AWS accounts that will be added to the aws-auth configmap"
        },
        "users": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.User"
          },
          "description": "This optional array defines additional IAM users that will be added to the aws-auth configmap"
        },
        "roles": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.AwsAuth.Role"
          },
          "description": "This optional array defines additional IAM roles that will be added to the aws-auth configmap"
        }
      }
    },
    "Spec.Kubernetes.AwsAuth.Role": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rolearn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": [
        "groups",
        "rolearn",
        "username"
      ]
    },
    "Spec.Kubernetes.AwsAuth.User": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "userarn": {
          "$ref": "#/$defs/Types.AwsArn"
        }
      },
      "required": [
        "groups",
        "userarn",
        "username"
      ]
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": [
        "modules"
      ],
      "if": {
        "allOf": [
          {
            "required": [
              "common"
            ]
          },
          {
            "properties": {
              "common": {
                "required": [
                  "provider"
                ]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": [
                      "type"
                    ]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      },
      "then": {
        "properties": {
          "modules": {
            "required": [
              "aws"
            ]
          }
        }
      },
      "else": {
        "properties": {
          "modules": {
            "properties": {
              "aws": {
                "type": "null"
              }
            }
          }
        }
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for all the KFD modules"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is registry.sighup.io/fury).\n\nNOTE: If plugins are pulling from the default registry, the registry will be replaced for these plugins too."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The type of the provider, must be EKS if specified"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "aws": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Aws"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": [
        "dr",
        "ingress",
        "logging",
        "policy"
      ]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "the base domain used for all the KFD ingresses, if in the nginx dual configuration, it should be the same as the .spec.distribution.modules.ingress.dns.private.name zone"
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the nginx ingress controller module"
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager"
        },
        "dns": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS"
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        }
      },
      "required": [
        "baseDomain",
        "nginx"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "type": {
                    "const": "dual"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dns"
            ],
            "properties": {
              "dns": {
                "required": [
                  "public",
                  "private"
                ]
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "type": {
                    "const": "single"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dns"
            ],
            "properties": {
              "dns": {
                "required": [
                  "public"
                ]
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "nginx": {
                "properties": {
                  "tls": {
                    "properties": {
                      "provider": {
                        "const": "certManager"
                      }
                    }
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "certManager"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the ingress module"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the ingress module"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "single",
            "dual"
          ],
          "description": "The type of the nginx ingress controller, must be ***none***, ***single*** or ***dual***"
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": [
            "certManager",
            "secret",
            "none"
          ],
          "description": "The provider of the TLS certificate, must be ***none***, ***certManager*** or ***secret***"
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": [
        "provider"
      ],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": [
          "secret"
        ]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file content or you can use the file notation to get the content from a file"
        },
        "key": {
          "type": "string"
        },
        "ca": {
          "type": "string"
        }
      },
      "required": [
        "ca",
        "cert",
        "key"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "clusterIssuer"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster issuer"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email of the cluster issuer"
        },
        "type": {
          "type": "string",
          "enum": [
            "dns01",
            "http01"
          ],
          "description": "The type of the cluster issuer, must be ***dns01*** or ***http01***"
        },
        "solvers": {
          "type": "array",
          "description": "The custom solvers configurations"
        }
      },
      "required": [
        "name",
        "email"
      ],
      "oneOf": [
        {
          "required": [
            "type"
          ]
        },
        {
          "required": [
            "solvers"
          ]
        }
      ]
    },
    "Spec.Distribution.Modules.Ingress.DNS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "public": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Public"
        },
        "private": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.DNS.Private"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.DNS.Public": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the public hosted zone"
        },
        "create": {
          "type": "boolean",
          "description": "If true, the public hosted zone will be created"
        }
      },
      "required": [
        "name",
        "create"
      ]
    },
    "Spec.Distribution.Modules.Ingress.DNS.Private": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the private hosted zone"
        },
        "create": {
          "type": "boolean",
          "description": "If true, the private hosted zone will be created"
        }
      },
      "required": [
        "name",
        "create"
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "opensearch",
            "loki",
            "customOutputs"
          ],
          "description": "selects the logging stack. Choosing none will disable the centralized logging. Choosing opensearch will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored. Choosing loki will use a distributed Grafana Loki instead of OpenSearh for storage. Choosing customOuput the Logging Operator will be deployed and installed but with no local storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": [
              "opensearch"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "loki"
              }
            }
          },
          "then": {
            "required": [
              "loki"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": [
              "customOutputs"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "single",
            "triple"
          ],
          "description": "The type of the opensearch, must be ***single*** or ***triple***"
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the opensearch pods"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each minio disk, 6 disks total"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username of the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password of the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the loki external endpoint"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the loki external endpoint will be insecure"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the loki external endpoint"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the loki external endpoint"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the loki external endpoint"
            }
          }
        },
        "tsdbStartDate": {
          "type": "string",
          "format": "date",
          "description": "Starting from versions 1.28.4, 1.29.5 and 1.30.0 of KFD, Loki will change the time series database from BoltDB to TSDB and the schema from v11 to v13 that it uses to store the logs.\n\nThe value of this field will determine the date when Loki will start writing using the new TSDB and the schema v13, always at midnight UTC. The old BoltDB and schema will be kept until they expire for reading purposes.\n\nValue must be a string in `ISO 8601` date format (`yyyy-mm-dd`). Example: `2024-11-18`."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      },
      "required": [
        "tsdbStartDate"
      ]
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "when using the customOutputs logging type, you need to manually specify the spec of the several Output and ClusterOutputs that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from Flow will be sent. Will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the nullout output to discard the flow."
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "configuration for the Monitoring module components",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "prometheus",
            "prometheusAgent",
            "mimir"
          ],
          "description": "The type of the monitoring, must be ***none***, ***prometheus***, ***prometheusAgent*** or ***mimir***.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instance, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: wil install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, and in addition Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the k8s Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the k8s Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the k8s Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook url to send deadman switch monitoring, for example to use with healthchecks.io"
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "If true, the default rules will be installed"
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The slack webhook url to send alerts"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string",
          "description": "[JMESPath](http://jmespath.org/examples.html) expression to retrieve the user's role. Example:\n\n```yaml\nusersRoleAttributePath: \"contains(groups[*], 'beta') && 'Admin' || contains(groups[*], 'gamma') && 'Editor' || contains(groups[*], 'delta') && 'Viewer'\n```\n\nMore details in [Grafana's documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/generic-oauth/#configure-role-mapping)."
        },
        "basicAuthIngress": {
          "type": "boolean",
          "description": "Setting this to true will deploy an additional `grafana-basic-auth` ingress protected with Grafana's basic auth instead of SSO. It's intended use is as a temporary ingress for when there are problems with the SSO login flow.\n\nNotice that by default anonymous access is enabled."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the mimir pods"
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The backend for the mimir pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external mimir backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external mimir backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external mimir backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external mimir backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external mimir backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "tempo"
          ],
          "description": "The type of tracing to use, either ***none*** or ***tempo***"
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the tempo pods"
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The backend for the tempo pods, must be ***minio*** or ***externalEndpoint***"
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The endpoint of the external tempo backend"
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, the external tempo backend will not use tls"
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key of the external tempo backend"
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key id of the external tempo backend"
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external tempo backend"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The storage size for the minio pods"
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the minio root user"
            },
            "password": {
              "type": "string",
              "description": "The password for the minio root user"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "gatekeeper",
            "kyverno"
          ],
          "description": "The type of security to use, either ***none***, ***gatekeeper*** or ***kyverno***"
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": [
              "gatekeeper"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": [
              "kyverno"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": [
            "deny",
            "dryrun",
            "warn"
          ],
          "description": "The enforcement action to use for the gatekeeper module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "enforcementAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the constraints on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": [
            "Audit",
            "Enforce"
          ],
          "description": "The validation failure action to use for the kyverno module"
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "If true, the default policies will be installed"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "validationFailureAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "eks"
          ],
          "description": "The type of the DR, must be ***none*** or ***eks***"
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": [
        "type"
      ],
      "if": {
        "properties": {
          "type": {
            "const": "eks"
          }
        }
      },
      "then": {
        "required": [
          "type",
          "velero"
        ]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "schedules": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Velero's backup schedules.",
          "properties": {
            "install": {
              "type": "boolean",
              "description": "Whether to install or not the default `manifests` and `full` backups schedules. Default is `true`."
            },
            "definitions": {
              "type": "object",
              "additionalProperties": false,
              "description": "Configuration for Velero schedules.",
              "properties": {
                "manifests": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `manifests` backup schedule (default `*/15 * * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    }
                  }
                },
                "full": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `full` backup schedule (default `0 1 * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    },
                    "snapshotMoveData": {
                      "type": "boolean",
                      "description": "EXPERIMENTAL (if you do more than one backups, the following backups after the first are not automatically restorable, see https://github.com/vmware-tanzu/velero/issues/7057#issuecomment-2466815898 for the manual restore solution): SnapshotMoveData specifies whether snapshot data should be moved. Velero will create a new volume from the snapshot and upload the content to the storageLocation."
                    }
                  }
                }
              }
            }
          }
        },
        "eks": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero.Eks"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "eks"
      ]
    },
    "Spec.Distribution.Modules.Dr.Velero.Eks": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "region": {
          "$ref": "#/$defs/Types.AwsRegion",
          "description": "The region where the velero bucket is located"
        },
        "bucketName": {
          "$ref": "#/$defs/Types.AwsS3BucketName",
          "maxLength": 49,
          "description": "The name of the velero bucket"
        }
      },
      "required": [
        "region",
        "bucketName"
      ]
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the auth module"
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        }
      },
      "required": [
        "provider"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dex",
              "pomerium",
              "baseDomain"
            ]
          },
          "else": {
            "properties": {
              "dex": {
                "type": "null"
              },
              "pomerium": {
                "type": "null"
              }
            }
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": [
                  "basicAuth"
                ]
              }
            }
          },
          "else": {
            "properties": {
              "provider": {
                "basicAuth": {
                  "type": "null"
                }
              }
            }
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the auth module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the auth module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      },
      "required": [
        "host",
        "ingressClass"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "basicAuth",
            "sso"
          ],
          "description": "The type of the provider, must be ***none***, ***sso*** or ***basicAuth***"
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for the basic auth"
        },
        "password": {
          "type": "string",
          "description": "The password for the basic auth"
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "../public/spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "connectors": {
          "type": "array",
          "description": "The connectors for dex"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "The additional static clients for dex"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "connectors"
      ]
    },
    "Spec.Distribution.Modules.Aws": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "clusterAutoscaler": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsCsiDriver": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "loadBalancerController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverridesWithIAMRoleName"
            }
          }
        },
        "ebsSnapshotController": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "overrides": {
              "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        }
      }
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.AwsArn": {
      "type": "string",
      "pattern": "^arn:(?P<Partition>[^:\\n]*):(?P<Service>[^:\\n]*):(?P<Region>[^:\\n]*):(?P<AccountID>[^:\\n]*):(?P<Ignore>(?P<ResourceType>[^:\\/\\n]*)[:\\/])?(?P<Resource>.*)$"
    },
    "Types.AwsRegion": {
      "type": "string",
      "enum": [
        "af-south-1",
        "ap-east-1",
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-northeast-3",
        "ap-south-1",
        "ap-south-2",
        "ap-southeast-1",
        "ap-southeast-2",
        "ap-southeast-3",
        "ap-southeast-4",
        "ca-central-1",
        "eu-central-1",
        "eu-central-2",
        "eu-north-1",
        "eu-south-1",
        "eu-south-2",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "me-central-1",
        "me-south-1",
        "sa-east-1",
        "us-east-1",
        "us-east-2",
        "us-gov-east-1",
        "us-gov-west-1",
        "us-west-1",
        "us-west-2"
      ]
    },
    "Types.AwsVpcId": {
      "type": "string",
      "pattern": "^vpc\\-([0-9a-f]{8}|[0-9a-f]{17})$"
    },
    "Types.AwsSshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(ed25519|rsa)\\s+"
    },
    "Types.AwsSubnetId": {
      "type": "string",
      "pattern": "^subnet\\-[0-9a-f]{17}$"
    },
    "Types.AwsTags": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.AwsIpProtocol": {
      "type": "string",
      "pattern": "^(?i)(tcp|udp|icmp|icmpv6|-1)$",
      "$comment": "this value should be lowercase, but we rely on terraform to do the conversion to make it a bit more user friendly"
    },
    "Types.AwsIamRoleNamePrefix": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,38}$"
    },
    "Types.AwsIamRoleName": {
      "type": "string",
      "pattern": "^[a-zA-Z0-9+=,.@_-]{1,63}$"
    },
    "Types.AwsS3BucketName": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,61}[a-z0-9]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3BucketNamePrefix": {
      "type": "string",
      "allOf": [
        {
          "pattern": "^[a-z0-9][a-z0-9-.]{1,35}[a-z0-9-.]$"
        },
        {
          "not": {
            "pattern": "^xn--|-s3alias$"
          }
        }
      ]
    },
    "Types.AwsS3KeyPrefix": {
      "type": "string",
      "pattern": "^[A-z0-9][A-z0-9!-_.*'()]+$",
      "maxLength": 960
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "array",
      "items": {
        "type": "string",
        "pattern": "^([a-zA-Z0-9\\-\\.\\/]+)=([^-][\\w-]+):(NoSchedule|PreferNoSchedule|NoExecute)$"
      }
    },
    "Types.KubeNodeSelector": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "Exists",
            "Equal"
          ]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": [
        "effect",
        "key"
      ],
      "anyOf": [
        {
          "required": [
            "operator"
          ]
        },
        {
          "required": [
            "value"
          ]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu request for the prometheus pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the opensearch pods"
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu limit for the opensearch pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the opensearch pods"
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the dr module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the monitoring module"
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the minio module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cert-manager module"
        }
      }
    },
    "Types.FuryModuleComponentOverridesWithIAMRoleName": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for the load balancer controller module"
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "The tolerations that will be added to the pods for the cluster autoscaler module"
        },
        "iamRoleName": {
          "$ref": "#/$defs/Types.AwsIamRoleName"
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication"
        },
        "host": {
          "type": "string",
          "description": "The host of the ingress"
        },
        "ingressClass": {
          "type": "string",
          "description": "The ingress class of the ingress"
        }
      }
    }
  }
}