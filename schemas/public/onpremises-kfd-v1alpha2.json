{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "A KFD Cluster deployed on top of a set of existing VMs.",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": [
        "OnPremises"
      ]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster. It will also be used as a prefix for all the other resources created.",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": [
        "name"
      ]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "description": "Defines which KFD version will be installed and, in consequence, the Kubernetes version used to create the cluster. It supports git tags and branches. Example: `v1.30.1`.",
          "minLength": 1
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "./spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "distribution"
      ]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "additionalProperties": false,
      "description": "Defines the Kubernetes components configuration and the values needed for the kubernetes phase of furyctl.",
      "properties": {
        "pkiFolder": {
          "type": "string",
          "description": "The path to the folder where the PKI files for Kubernetes and etcd are stored."
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Kubernetes.SSH"
        },
        "dnsZone": {
          "type": "string",
          "description": "The DNS zone of the machines. It will be appended to the name of each host to generate the `kubernetes_hostname` in the Ansible inventory file. It is also used to calculate etcd's initial cluster value."
        },
        "controlPlaneAddress": {
          "type": "string",
          "description": "The address for the Kubernetes control plane. Usually a DNS entry pointing to a Load Balancer on port 6443."
        },
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The subnet CIDR to use for the Pods network."
        },
        "svcCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The subnet CIDR to use for the Services network."
        },
        "proxy": {
          "$ref": "#/$defs/Spec.Kubernetes.Proxy"
        },
        "loadBalancers": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers"
        },
        "masters": {
          "$ref": "#/$defs/Spec.Kubernetes.Masters"
        },
        "etcd": {
          "$ref": "#/$defs/Spec.Kubernetes.Etcd"
        },
        "nodes": {
          "$ref": "#/$defs/Spec.Kubernetes.Nodes"
        },
        "advanced": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced"
        },
        "advancedAnsible": {
          "$ref": "#/$defs/Spec.Kubernetes.AdvancedAnsible"
        }
      },
      "required": [
        "pkiFolder",
        "ssh",
        "dnsZone",
        "controlPlaneAddress",
        "podCidr",
        "svcCidr",
        "loadBalancers",
        "masters",
        "nodes"
      ]
    },
    "Spec.Kubernetes.SSH": {
      "type": "object",
      "additionalProperties": false,
      "description": "SSH credentials to access the hosts",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username to use to connect to the hosts"
        },
        "keyPath": {
          "type": "string",
          "description": "The path to the private key to use to connect to the hosts"
        }
      },
      "required": [
        "username",
        "keyPath"
      ]
    },
    "Spec.Kubernetes.Proxy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "http": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTP proxy URL. Example: http://test.example.dev:3128"
        },
        "https": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTPS proxy URL. Example: https://test.example.dev:3128"
        },
        "noProxy": {
          "type": "string",
          "description": "Comma-separated list of hosts that should not use the HTTP(S) proxy. Example:\nlocalhost,127.0.0.1,172.16.0.0/17,172.16.128.0/17,10.0.0.0/8,.example.dev"
        }
      },
      "required": []
    },
    "Spec.Kubernetes.LoadBalancers": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to true to install HAProxy and configure it as a load balancer on the the load balancer hosts."
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Host"
          }
        },
        "keepalived": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Keepalived"
        },
        "stats": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Stats"
        },
        "additionalConfig": {
          "type": "string",
          "description": "Additional configuration to append to HAProxy's configuration file."
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "hosts",
          "keepalived",
          "stats"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the host. This value will be concatenated to `.spec.kubernetes.dnsZone` to calculate the FQDN for the host as `<name>.<dnsZone>`."
        },
        "ip": {
          "type": "string",
          "description": "The IP address of the host."
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.LoadBalancers.Keepalived": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to install keepalived with a floating virtual IP shared between the load balancer hosts for a deployment in High Availability."
        },
        "interface": {
          "type": "string",
          "description": "Name of the network interface where to bind the Keepalived virtual IP."
        },
        "ip": {
          "type": "string",
          "description": "The Virtual floating IP for Keepalived"
        },
        "virtualRouterId": {
          "type": "string",
          "description": "The virtual router ID of Keepalived, an arbitrary unique number from 1 to 255 used to differentiate multiple instances of vrrpd running on the same network interface and address family and multicast/unicast (and hence same socket)."
        },
        "passphrase": {
          "type": "string",
          "description": "Password for accessing vrrpd. Make it unique between Keepalived clusters.",
          "maxLength": 8
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "interface",
          "ip",
          "virtualRouterId",
          "passphrase"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Stats": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for HAProxy stats page. Accessible at http://<haproxy host>:1936/stats",
      "properties": {
        "username": {
          "type": "string",
          "description": "The basic-auth username for HAProxy's stats page"
        },
        "password": {
          "type": "string",
          "description": "The basic-auth password for HAProxy's stats page."
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Kubernetes.Masters": {
      "type": "object",
      "description": "Configuration for the control plane hosts",
      "additionalProperties": false,
      "properties": {
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Masters.Host"
          }
        },
        "labels": {
          "description": "Optional additional Kubernetes labels that will be added to the control-plane nodes. Follows Kubernetes labels format.\n\nNote: **Existing labels with the same key will be overwritten** and the label setting the `control-plane` role cannot be deleted.",
          "$ref": "#/$defs/Types.KubeLabels"
        },
        "annotations": {
          "description": "Optional additional Kubernetes annotations that will be added to the control-plane nodes. Follows Kubernetes annotations format. **Existing annotations with the same key will be overwritten**.",
          "$ref": "#/$defs/Types.KubeAnnotations"
        }
      },
      "required": [
        "hosts"
      ]
    },
    "Spec.Kubernetes.Masters.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the host. This value will be concatenated to `.spec.kubernetes.dnsZone` to calculate the FQDN for the host as `<name>.<dnsZone>`."
        },
        "ip": {
          "type": "string",
          "description": "The IP address of the host"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.Etcd": {
      "type": "object",
      "description": "Optional configuration for an etcd cluster on dedicated nodes. If omitted, etcd will run on control plane nodes.",
      "additionalProperties": false,
      "properties": {
        "hosts": {
          "type": "array",
          "description": "List of nodes of the dedicated etcd cluster.",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Etcd.Host"
          },
          "minItems": 1
        }
      },
      "required": ["hosts"]
    },
    "Spec.Kubernetes.Etcd.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the etcd node. This value will be concatenated to `.spec.kubernetes.dnsZone` to calculate the FQDN for the host as `<name>.<dnsZone>`."
        },
        "ip": {
          "type": "string",
          "description": "The IP address of the etcd node."
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.Nodes": {
      "type": "array",
      "description": "Configuration for the node hosts",
      "minItems": 0,
      "items": {
        "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node"
      }
    },
    "Spec.Kubernetes.Nodes.Node": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "Name for the node group. It will be also used as the node role label. It should follow the [valid variable names guideline](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#valid-variable-names) from Ansible."
        },
        "hosts": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node.Host"
          }
        },
        "taints": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeTaints"
          }
        },
        "labels": {
          "description": "Optional additional Kubernetes labels that will be added to the nodes in this node group. Follows Kubernetes labels format.\n\nNote: **Existing labels with the same key will be overwritten** and the label setting the node role to the node group name cannot be deleted.",
          "$ref": "#/$defs/Types.KubeLabels"
        },
        "annotations": {
          "description": "Optional additional Kubernetes annotations that will be added to the nodes in this node group. Follows Kubernetes annotations format. **Existing annotations with the same key will be overwritten**.",
          "$ref": "#/$defs/Types.KubeAnnotations"
        }
      },
      "required": [
        "name",
        "hosts"
      ]
    },
    "Spec.Kubernetes.Nodes.Node.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "A name to identify the host. This value will be concatenated to `.spec.kubernetes.dnsZone` to calculate the FQDN for the host as `<name>.<dnsZone>`.",
          "type": "string"
        },
        "ip": {
          "description": "The IP address of the host",
          "type": "string"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.AdvancedAnsible": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pythonInterpreter": {
          "type": "string",
          "description": "The Python interpreter to use for running Ansible. Example: python3"
        },
        "config": {
          "type": "string",
          "description": "Additional configuration to append to the ansible.cfg file"
        }
      }
    },
    "Spec.Kubernetes.Advanced": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cloud": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Cloud"
        },
        "users": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Users"
        },
        "oidc": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.OIDC"
        },
        "containerd": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd"
        },
        "encryption": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Encryption"
        },
        "airGap": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.AirGap"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Kubernetes phase. (Default is registry.sighup.io/fury/on-premises)."
        }
      }
    },
    "Spec.Kubernetes.Advanced.Cloud": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "description": "Sets the cloud provider for the Kubelet"
        },
        "config": {
          "type": "string",
          "description": "Sets cloud config for the Kubelet"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Users": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of user names to create and get a kubeconfig file. Users will not have any permissions by default, RBAC setup for the new users is needed."
        },
        "org": {
          "type": "string",
          "description": "The organization the users belong to."
        }
      }
    },
    "Spec.Kubernetes.Advanced.OIDC": {
      "type": "object",
      "additionalProperties": false,
      "description": "OIDC configuration for the Kubernetes API server.",
      "properties": {
        "issuer_url": {
          "type": "string",
          "description": "The issuer URL of the OIDC provider."
        },
        "client_id": {
          "type": "string",
          "description": "The client ID the API server will use to authenticate to the OIDC provider."
        },
        "ca_file": {
          "type": "string",
          "description": "The path to the certificate for the CA that signed the identity provider's web certificate. Defaults to the host's root CAs. This should be a path available to the API Server."
        },
        "username_claim": {
          "type": "string",
          "description": "JWT claim to use as the user name. The default value is `sub`, which is expected to be a unique identifier of the end user."
        },
        "username_prefix": {
          "type": "string",
          "description": "Prefix prepended to username claims to prevent clashes with existing names (such as system: users)."
        },
        "groups_claim": {
          "type": "string",
          "description": "JWT claim to use as the user's group."
        },
        "group_prefix": {
          "type": "string",
          "description": "Prefix prepended to group claims to prevent clashes with existing names (such as system: groups)."
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd": {
      "type": "object",
      "additionalProperties": false,
      "description": "Advanced configuration for containerd",
      "properties": {
        "registryConfigs": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd.RegistryConfigs"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd.RegistryConfigs": {
      "description": "Allows specifying custom configuration for a registry at containerd level. You can set authentication details and mirrors for a registry.\nThis feature can be used for example to authenticate to a private registry at containerd (container runtime) level, i.e. globally instead of using `imagePullSecrets`. It also can be used to use a mirror for a registry or to enable insecure connections to trusted registries that have self-signed certificates.",
      "type": "array",
      "additionalProperties": false,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "registry": {
            "type": "string",
            "description": "Registry address on which you would like to configure authentication or mirror(s). Example: `myregistry.tld:5000`"
          },
          "username": {
            "type": "string",
            "description": "The username containerd will use to authenticate against the registry."
          },
          "password": {
            "type": "string",
            "description": "The password containerd will use to authenticate against the registry."
          },
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "Set to `true` to skip TLS verification (e.g. when using self-signed certificates)."
          },
          "mirrorEndpoint": {
            "type": "array",
            "description": "Array of URLs with the mirrors to use for the registry. Example: `[\"http://mymirror.tld:8080\"]`",
            "items": {
              "type": "string"
            }
          }
        }
      }
    },
    "Spec.Kubernetes.Advanced.Encryption": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "tlsCipherSuites": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The TLS cipher suites to use for etcd, kubelet, and kubeadm static pods. Example:\n```yaml\ntlsCipherSuites:\n  - \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"\n  - \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\"\n  - \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\"\n  - \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"\n  - \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\"\n  - \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\"\n  - \"TLS_AES_128_GCM_SHA256\"\n  - \"TLS_AES_256_GCM_SHA384\"\n  - \"TLS_CHACHA20_POLY1305_SHA256\"\n```"
        },
        "configuration": {
          "type": "string",
          "description": "etcd's encryption at rest configuration. Must be a string with the EncryptionConfiguration object in YAML. Example:\n\n```yaml\n\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: mykey\n          secret: base64_encoded_secret\n```\n"
        }
      }
    },
    "Spec.Kubernetes.Advanced.AirGap": {
      "type": "object",
      "description": "Advanced configuration for air-gapped installations. Allows setting custom URLs where to download the binaries dependencies from and custom .deb and .rpm package repositories.",
      "additionalProperties": false,
      "properties": {
        "containerdDownloadUrl": {
          "type": "string",
          "description": "URL where to download the `.tar.gz` with containerd from. The `tar.gz` should be as the one downloaded from containerd GitHub releases page."
        },
        "runcDownloadUrl": {
          "type": "string",
          "description": "URL where to download the runc binary from."
        },
        "runcChecksum": {
          "type": "string",
          "description": "Checksum for the runc binary."
        },
        "etcdDownloadUrl": {
          "type": "string",
          "description": "URL to the path where the etcd `tar.gz`s are available. etcd will be downloaded from `<etcdDownloadUrl>/<etcd_version>/etcd-<etcd_version>-linux-<host_architecture>.tar.gz`"
        },
        "dependenciesOverride": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "apt": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "An indicative name for the Apt repository. Example: `k8s-1.29`"
                },
                "repo": {
                  "type": "string",
                  "description": "A source string for the new Apt repository. Example: `deb https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /`"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "URL where to download the GPG key of the Apt repository. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key`"
                },
                "gpg_key_id": {
                  "type": "string",
                  "description": "The GPG key ID of the Apt repository. Example: `36A1D7869245C8950F966E92D8576A8BA88D21E9`"
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_id"
              ]
            },
            "yum": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "An indicative name for the Yum repository. Example: `k8s-1.29`"
                },
                "repo": {
                  "type": "string",
                  "description": "URL to the directory where the Yum repository's `repodata` directory lives. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/rpm/`"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "URL where to download the ASCII-armored GPG key of the Yum repository. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key`"
                },
                "gpg_key_check": {
                  "type": "boolean",
                  "description": "If true, the GPG signature check on the packages will be enabled."
                },
                "repo_gpg_check": {
                  "type": "boolean",
                  "description": "If true, the GPG signature check on the `repodata` will be enabled."
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_check",
                "repo_gpg_check"
              ]
            }
          }
        }
      }
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": [
        "modules"
      ],
      "if": {
        "allOf": [
          {
            "required": [
              "common"
            ]
          },
          {
            "properties": {
              "common": {
                "required": [
                  "provider"
                ]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": [
                      "type"
                    ]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "description": "Common configuration for all the distribution modules.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules. Follows Kubernetes selector format. Example: `node.kubernetes.io/role: infra`."
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "An array with the tolerations that will be added to the pods for all the KFD modules. Follows Kubernetes tolerations format. Example:\n\n```yaml\n- effect: NoSchedule\n  key: node.kubernetes.io/role\n  value: infra\n```"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed."
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is `registry.sighup.io/fury`).\n\nNOTE: If plugins are pulling from the default registry, the registry will be replaced for the plugin too."
        },
        "networkPoliciesEnabled": {
          "type": "boolean",
          "description": "EXPERIMENTAL FEATURE. This field defines whether Network Policies are provided for core modules."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The provider type. Don't set. FOR INTERNAL USE ONLY."
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": [
        "dr",
        "ingress",
        "logging",
        "policy"
      ]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain used for all the KFD infrastructural ingresses. If using the nginx `dual` type, this value should be the same as the domain associated with the `internal` ingress class."
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the Ingress nginx controller package."
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager",
          "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses."
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        },
        "if": {
          "properties": {
            "nginx": {
              "properties": {
                "tls": {
                  "properties": {
                    "provider": {
                      "const": "certManager"
                    }
                  }
                }
              }
            }
          }
        },
        "then": {
          "required": [
            "certManager"
          ]
        }
      },
      "required": [
        "baseDomain",
        "nginx"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Ingress module.",
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Ingress module."
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Ingress module."
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "single",
            "dual"
          ],
          "description": "The type of the Ingress nginx controller, options are:\n- `none`: no ingress controller will be installed and no infrastructural ingresses will be created.\n- `single`: a single ingress controller with ingress class `nginx` will be installed to manage all the ingress resources, infrastructural ingresses will be created.\n- `dual`: two independent ingress controllers will be installed, one for the `internal` ingress class intended for private ingresses and one for the `external` ingress class intended for public ingresses. KFD infrastructural ingresses wil use the `internal` ingress class when using the dual type.\n\nDefault is `single`."
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": [
            "certManager",
            "secret",
            "none"
          ],
          "description": "The provider of the TLS certificates for the ingresses, one of: `none`, `certManager`, or `secret`."
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": [
        "provider"
      ],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": [
          "secret"
        ]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "description": "Kubernetes TLS secret for the ingresses TLS certificate.",
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "key": {
          "type": "string",
          "description": "The signing key file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "ca": {
          "type": "string",
          "description": "The Certificate Authority certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        }
      },
      "required": [
        "ca",
        "cert",
        "key"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses.",
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "clusterIssuer"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager's ACME clusterIssuer used to request certificates from Let's Encrypt.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the clusterIssuer."
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email address to use during the certificate issuing process."
        },
        "type": {
          "type": "string",
          "enum": [
            "http01"
          ],
          "description": "The type of the clusterIssuer. Only `http01` challenge is supported for on-premises clusters. See solvers for arbitrary configurations."
        },
        "solvers": {
          "type": "array",
          "description": "The list of challenge solvers to use instead of the default one for the `http01` challenge. Check [cert manager's documentation](https://cert-manager.io/docs/configuration/acme/#adding-multiple-solver-types) for examples for this field."
        }
      },
      "required": [
        "name",
        "email"
      ],
      "oneOf": [
        {
          "required": [
            "type"
          ]
        },
        {
          "required": [
            "solvers"
          ]
        }
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "opensearch",
            "loki",
            "customOutputs"
          ],
          "description": "Selects the logging stack. Options are:\n- `none`: will disable the centralized logging.\n- `opensearch`: will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored.\n- `loki`: will use a distributed Grafana Loki instead of OpenSearch for storage.\n- `customOuputs`: the Logging Operator will be deployed and installed but without in-cluster storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage.\n\nDefault is `opensearch`."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": [
              "opensearch"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "loki"
              }
            }
          },
          "then": {
            "required": [
              "loki"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": [
              "customOutputs"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "single",
            "triple"
          ],
          "description": "The type of OpenSearch deployment. One of: `single` for a single replica or `triple` for an HA 3-replicas deployment."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the OpenSearch volumes. Follows Kubernetes resources storage requests. Default is `150Gi`."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "description": "DEPRECATED since KFD v1.26.6, 1.27.5, v1.28.0.",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for Logging's MinIO deployment.",
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "description": "Configuration for the Loki package.",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "description": "The storage backend type for Loki. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external object storage instead of deploying an in-cluster MinIO.",
          "enum": [
            "minio",
            "externalEndpoint"
          ]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Loki's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Loki's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "tsdbStartDate": {
          "type": "string",
          "format": "date",
          "description": "Starting from versions 1.28.4, 1.29.5 and 1.30.0 of KFD, Loki will change the time series database from BoltDB to TSDB and the schema from v11 to v13 that it uses to store the logs.\n\nThe value of this field will determine the date when Loki will start writing using the new TSDB and the schema v13, always at midnight UTC. The old BoltDB and schema will be kept until they expire for reading purposes.\n\nValue must be a string in `ISO 8601` date format (`yyyy-mm-dd`). Example: `2024-11-18`."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      },
      "required": [
        "tsdbStartDate"
      ]
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging Operator.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "When using the `customOutputs` logging type, you need to manually specify the spec of the several `Output` and `ClusterOutputs` that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from the `audit` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from the `events` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from the `infra` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from the `ingressNginx` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from the `kubernetes` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from the `systemdCommon` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from the `systemdEtcd` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from the `errors` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Monitoring module.",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "prometheus",
            "prometheusAgent",
            "mimir"
          ],
          "description": "The type of the monitoring, must be `none`, `prometheus`, `prometheusAgent` or `mimir`.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instance, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: will install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, plus Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage.\n\nDefault is `prometheus`."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the `k8s` Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the `k8s` Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the `k8s` Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook URL to send dead man's switch monitoring, for example to use with healthchecks.io."
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "Set to false to avoid installing the Prometheus rules (alerts) included with the distribution."
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The Slack webhook URL where to send the infrastructural and workload alerts to."
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string",
          "description": "[JMESPath](http://jmespath.org/examples.html) expression to retrieve the user's role. Example:\n\n```yaml\nusersRoleAttributePath: \"contains(groups[*], 'beta') && 'Admin' || contains(groups[*], 'gamma') && 'Editor' || contains(groups[*], 'delta') && 'Viewer'\n```\n\nMore details in [Grafana's documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/generic-oauth/#configure-role-mapping)."
        },
        "basicAuthIngress": {
          "type": "boolean",
          "description": "Setting this to true will deploy an additional `grafana-basic-auth` ingress protected with Grafana's basic auth instead of SSO. It's intended use is as a temporary ingress for when there are problems with the SSO login flow.\n\nNotice that by default anonymous access is enabled."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Mimir package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the logs stored in Mimir. Default is `30d`. Value must match the regular expression `[0-9]+(ns|us|µs|ms|s|m|h|d|w|y)` where y = 365 days."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Mimir. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Mimir's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The external S3-compatible endpoint for Mimir's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "description": "Configuration for Monitoring's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tracing module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "tempo"
          ],
          "description": "The type of tracing to use, either `none` or `tempo`. `none` will disable the Tracing module and `tempo` will install a Grafana Tempo deployment.\n\nDefault is `tempo`."
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tempo package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the traces stored in Tempo."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Tempo. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "description": "Configuration for Tempo's external storage backend.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "The external S3-compatible endpoint for Tempo's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "description": "Configuration for Tracing's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Networking module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        },
        "cilium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.Cilium"
        },
        "type": {
          "type": "string",
          "enum": [
            "calico",
            "cilium"
          ],
          "description": "The type of CNI plugin to use, either `calico` (Tigera Operator) or `cilium`. Default is `calico`."
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.Cilium": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "Allows specifing a CIDR for the Pods network different from `.spec.kubernetes.podCidr`. If not set the default is to use `.spec.kubernetes.podCidr`."
        },
        "maskSize": {
          "type": "string",
          "description": "The mask size to use for the Pods network on each node."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Policy module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "gatekeeper",
            "kyverno"
          ],
          "description": "The type of policy enforcement to use, either `none`, `gatekeeper` or `kyverno`.\n\nDefault is `none`."
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": [
              "gatekeeper"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": [
              "kyverno"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Gatekeeper package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": [
            "deny",
            "dryrun",
            "warn"
          ],
          "description": "The default enforcement action to use for the included constraints. `deny` will block the admission when violations to the policies are found, `warn` will show a message to the user but will admit the violating requests and `dryrun` won't give any feedback to the user but it will log the violations."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Gatekeeper policies (constraints templates and constraints) included with the distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "enforcementAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Kyverno package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the policies on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": [
            "Audit",
            "Enforce"
          ],
          "description": "The validation failure action to use for the included policies, `Enforce` will block when a request does not comply with the policies and `Audit` will not block but log when a request does not comply with the policies."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Kyverno policies included with distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "validationFailureAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Disaster Recovery module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "on-premises"
          ],
          "description": "The type of the Disaster Recovery, must be `none` or `on-premises`. `none` disables the module and `on-premises` will install Velero, an optional MinIO deployment and optionally etcd-backup.\n\nDefault is `none`."
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        },
        "etcdBackup": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.EtcdBackup"
        }
      },
      "required": [
        "type"
      ],
      "if": {
        "properties": {
          "type": {
            "const": "on-premises"
          }
        }
      },
      "then": {
        "required": [
          "type",
          "velero",
          "etcdBackup"
        ]
      }
    },
    "Spec.Distribution.Modules.Dr.EtcdBackup": {
      "type": "object",
      "description": "Configuration for the ETCD backup package.",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "s3",
            "pvc",
            "none",
            "all"
          ],
          "description": "The type of the etcd backup to enable, options are:\n- `none`: no etcd backup CronJob will be installed and no etcd backup will be performed.\n- `s3`: the etcd-backup-s3 package will be enabled. It will deploy a CronJob which continuously snapshots a healthy etcd node and will save the backups in a configured S3 bucket.\n- `pvc`: the etcd-backup-pvc package will be enabled. It will deploy a CronJob which continuously snapshots a healthy etcd node and will save the backups in a configured PersistentVolumeClaim.\n- `all`: both kinds of backups will be enabled.\n\nDefault is `none`."
        },
        "backupPrefix": {
          "type": "string",
          "additionalProperties": false,
          "description": "A prefix to be prepended to the backup filenames. If unset, the prefix defaults to the cluster's name."
        },
        "persistentVolumeClaim": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration parameters for the `pvc` type of `etcdBackup`.",
          "properties": {
            "schedule": {
              "type": "string",
              "description": "The cron expression for the `etcd-backup-pvc` backup schedule. Default is `0 1 * * *` (everyday at 01:00)."
            },
            "claimName": {
              "type": "string",
              "description": "The PersistentVolumeClaim name where the backups will be saved. NOTE: The PVC must exist and must be created separately."
            },
            "retentionTime": {
              "type": "string",
              "description": "The retention time of the backups inside the PersistentVolumeClaim. Follows rclone's `min-age` format. Example: '30d' for 30 days. Default is `10d` (ten days)."
            }
          }
        },
        "s3": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration parameters for the `s3` type of `etcdBackup`.",
          "properties": {
            "schedule": {
              "type": "string",
              "description": "The cron expression for the `etcd-backup-s3` backup schedule. Default is `0 1 * * *` (everyday at 01:00)."
            },
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for etcd-backup-s3's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            },
            "retentionTime": {
              "type": "string",
              "description": "The retention time of the external S3-compatible object storage. Follows rclone's `min-age` format. Example: '30d' for 30 days. Default is `10d` (ten days)."
            }
          }
        }
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Velero package.",
      "properties": {
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Velero. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Velero's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Velero's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "schedules": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Velero's backup schedules.",
          "properties": {
            "install": {
              "type": "boolean",
              "description": "Whether to install or not the default `manifests` and `full` backups schedules. Default is `true`."
            },
            "definitions": {
              "type": "object",
              "additionalProperties": false,
              "description": "Configuration for Velero schedules.",
              "properties": {
                "manifests": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `manifests` backup schedule (default `*/15 * * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    }
                  }
                },
                "full": {
                  "type": "object",
                  "additionalProperties": false,
                  "description": "Configuration for Velero's manifests backup schedule.",
                  "properties": {
                    "schedule": {
                      "type": "string",
                      "description": "The cron expression for the `full` backup schedule (default `0 1 * * *`)."
                    },
                    "ttl": {
                      "type": "string",
                      "description": "The Time To Live (TTL) of the backups created by the backup schedules (default `720h0m0s`, 30 days). Notice that changing this value will affect only newly created backups, prior backups will keep the old TTL."
                    },
                    "snapshotMoveData": {
                      "type": "boolean",
                      "description": "EXPERIMENTAL (if you do more than one backups, the following backups after the first are not automatically restorable, see https://github.com/vmware-tanzu/velero/issues/7057#issuecomment-2466815898 for the manual restore solution): SnapshotMoveData specifies whether snapshot data should be moved. Velero will create a new volume from the snapshot and upload the content to the storageLocation."
                    }
                  }
                }
              }
            }
          }
        },
        "snapshotController": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for the additional snapshotController component installation.",
          "properties": {
            "install": {
              "type": "boolean",
              "description": "Whether to install or not the snapshotController component in the cluster. Before enabling this field, check if your CSI driver does not have snapshotController built-in."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Auth module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain for the ingresses created by the Auth module (Gangplank, Pomerium, Dex). Notice that when the ingress module type is `dual`, these will use the `external` ingress class."
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        },
        "oidcKubernetesAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.OIDCKubernetesAuth"
        }
      },
      "required": [
        "provider"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dex",
              "pomerium",
              "baseDomain"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": [
                  "basicAuth"
                ]
              }
            }
          }
        },
        {
          "allOf": [
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "type": "object"
                  }
                }
              }
            },
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "properties": {
                      "enabled": {
                        "const": true
                      }
                    }
                  }
                }
              }
            }
          ],
          "then": {
            "required": [
              "baseDomain",
              "dex"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Auth module.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Auth module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Auth module."
        },
        "ingresses": {
          "additionalProperties": false,
          "type": "object",
          "description": "Override the definition of the Auth module ingresses.",
          "properties": {
            "gangplank": {
              "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
            },
            "dex": {
              "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
            }
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      },
      "required": [
        "host",
        "ingressClass"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "basicAuth",
            "sso"
          ],
          "description": "The type of the Auth provider, options are:\n- `none`: will disable authentication in the infrastructural ingresses.\n- `sso`: will protect the infrastructural ingresses with Pomerium and Dex (SSO) and require authentication before accessing them.\n- `basicAuth`: will protect the infrastructural ingresses with HTTP basic auth (username and password) authentication.\n\nDefault is `none`."
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the HTTP Basic Auth provider.",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for logging in with the HTTP basic authentication."
        },
        "password": {
          "type": "string",
          "description": "The password for logging in with the HTTP basic authentication."
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "./spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Dex package.",
      "properties": {
        "connectors": {
          "type": "array",
          "description": "A list with each item defining a Dex connector. Follows Dex connectors configuration format: https://dexidp.io/docs/connectors/"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "Additional static clients defitions that will be added to the default clients included with the distribution in Dex's configuration. Example:\n\n```yaml\nadditionalStaticClients:\n  - id: my-custom-client\n    name: \"A custom additional static client\"\n    redirectURIs:\n      - \"https://myapp.tld/redirect\"\n      - \"https://alias.tld/oidc-callback\"\n    secret: supersecretpassword\n```\nReference: https://dexidp.io/docs/connectors/local/"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "connectors"
      ]
    },
    "Spec.Distribution.Modules.Auth.OIDCKubernetesAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If true, components needed for interacting with the Kubernetes API with OIDC authentication (Gangplank, Dex) be deployed and configued."
        },
        "clientID": {
          "type": "string",
          "description": "The client ID that the Kubernetes API will use to authenticate against the OIDC provider (Dex)."
        },
        "clientSecret": {
          "type": "string",
          "description": "The client secret that the Kubernetes API will use to authenticate against the OIDC provider (Dex)."
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Used to specify the scope of the requested Oauth authorization by Gangplank. Defaults to: `[\"openid\", \"profile\", \"email\", \"offline_access\", \"groups\"]`"
        },
        "usernameClaim": {
          "type": "string",
          "description": "The JWT claim to use as the username. This is used in Gangplank's UI. This is combined with the clusterName for the user portion of the kubeconfig. Defaults to `nickname`."
        },
        "emailClaim": {
          "type": "string",
          "description": "DEPRECATED. Defaults to `email`."
        },
        "sessionSecurityKey": {
          "type": "string",
          "description": "The Key to use for the sessions in Gangplank. Must be different between different instances of Gangplank."
        },
        "removeCAFromKubeconfig": {
          "type": "boolean",
          "description": "Set to true to remove the CA from the kubeconfig file generated by Gangplank."
        },
        "namespace": {
          "type": "string",
          "description": "The namespace to set in the context of the kubeconfig file generated by Gangplank. Defaults to `default`."
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "clientID",
          "clientSecret",
          "sessionSecurityKey"
        ]
      }
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.KubeLabels": {
      "type": [
        "object",
        "null"
      ],
      "propertyNames": {
        "pattern": "^([a-zA-Z0-9][a-zA-Z0-9-.]*[a-zA-Z0-9]/)?([a-zA-Z0-9][-a-zA-Z0-9_.]*)?[a-zA-Z0-9]$",
        "maxLength": 253
      },
      "additionalProperties": {
        "type": "string",
        "pattern": "^(([a-zA-Z0-9][-a-zA-Z0-9_.]*)?[a-zA-Z0-9])?$",
        "maxLength": 63
      }
    },
    "Types.KubeAnnotations": {
      "type": [
        "object",
        "null"
      ],
      "propertyNames": {
        "pattern": "^([a-zA-Z0-9][a-zA-Z0-9-.]*[a-zA-Z0-9]/)?([a-zA-Z0-9][-a-zA-Z0-9_.]*)?[a-zA-Z0-9]$",
        "maxLength": 253
      },
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "required": [
        "effect",
        "key",
        "value"
      ]
    },
    "Types.KubeNodeSelector": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "Exists",
            "Equal"
          ]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": [
        "effect",
        "key"
      ],
      "anyOf": [
        {
          "required": [
            "operator"
          ]
        },
        {
          "required": [
            "value"
          ]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The CPU request for the Pod, in cores. Example: `500m`."
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the Pod. Example: `500M`."
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The CPU limit for the Pod. Example: `1000m`."
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the Pod. Example: `1G`."
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "description": "Override the common configuration with a particular configuration for the module.",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the module."
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the package."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the package."
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication even if `.spec.modules.auth.provider.type` is SSO or Basic Auth."
        },
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      }
    }
  }
}
