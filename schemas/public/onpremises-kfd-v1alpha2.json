{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "description": "",
  "type": "object",
  "properties": {
    "apiVersion": {
      "type": "string",
      "pattern": "^kfd\\.sighup\\.io/v\\d+((alpha|beta)\\d+)?$"
    },
    "kind": {
      "type": "string",
      "enum": [
        "OnPremises"
      ]
    },
    "metadata": {
      "$ref": "#/$defs/Metadata"
    },
    "spec": {
      "$ref": "#/$defs/Spec"
    }
  },
  "additionalProperties": false,
  "required": [
    "apiVersion",
    "kind",
    "metadata",
    "spec"
  ],
  "$defs": {
    "Metadata": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the cluster. It will also be used as a prefix for all the other resources created.",
          "minLength": 1,
          "maxLength": 56
        }
      },
      "required": [
        "name"
      ]
    },
    "Spec": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "distributionVersion": {
          "type": "string",
          "description": "Defines which KFD version will be installed and, in consequence, the Kubernetes version used to create the cluster. It supports git tags and branches. Example: v1.30.1.",
          "minLength": 1
        },
        "kubernetes": {
          "$ref": "#/$defs/Spec.Kubernetes"
        },
        "distribution": {
          "$ref": "#/$defs/Spec.Distribution"
        },
        "plugins": {
          "$ref": "./spec-plugins.json"
        }
      },
      "required": [
        "distributionVersion",
        "distribution"
      ]
    },
    "Spec.Kubernetes": {
      "type": "object",
      "additionalProperties": false,
      "description": "Defines the Kubernetes components configuration and the values needed for the kubernetes phase of furyctl.",
      "properties": {
        "pkiFolder": {
          "type": "string",
          "description": "The path to the folder where the PKI files for Kubernetes and etcd are stored."
        },
        "ssh": {
          "$ref": "#/$defs/Spec.Kubernetes.SSH"
        },
        "dnsZone": {
          "type": "string",
          "description": "The DNS zone of the machines. It will be appended to the name of each host to generate the `kubernetes_hostname` in the Ansible inventory file. It is also used to calculate etcd's initial cluster value."
        },
        "controlPlaneAddress": {
          "type": "string",
          "description": "The address for the Kubernetes control plane. Usually a DNS entry pointing to a Load Balancer on port 6443."
        },
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The subnet CIDR to use for the Pods network."
        },
        "svcCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "The subnet CIDR to use for the Services network."
        },
        "proxy": {
          "$ref": "#/$defs/Spec.Kubernetes.Proxy"
        },
        "loadBalancers": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers"
        },
        "masters": {
          "$ref": "#/$defs/Spec.Kubernetes.Masters"
        },
        "nodes": {
          "$ref": "#/$defs/Spec.Kubernetes.Nodes"
        },
        "advanced": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced"
        },
        "advancedAnsible": {
          "$ref": "#/$defs/Spec.Kubernetes.AdvancedAnsible"
        }
      },
      "required": [
        "pkiFolder",
        "ssh",
        "dnsZone",
        "controlPlaneAddress",
        "podCidr",
        "svcCidr",
        "loadBalancers",
        "masters",
        "nodes"
      ]
    },
    "Spec.Kubernetes.SSH": {
      "type": "object",
      "additionalProperties": false,
      "description": "SSH credentials to access the hosts",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username to use to connect to the hosts"
        },
        "keyPath": {
          "type": "string",
          "description": "The path to the private key to use to connect to the hosts"
        }
      },
      "required": [
        "username",
        "keyPath"
      ]
    },
    "Spec.Kubernetes.Proxy": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "http": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTP proxy URL. Example: http://test.example.dev:3128"
        },
        "https": {
          "$ref": "#/$defs/Types.Uri",
          "description": "The HTTPS proxy URL. Example: https://test.example.dev:3128"
        },
        "noProxy": {
          "type": "string",
          "description": "Comma-separated list of hosts that should not use the HTTP(S) proxy. Example:\nlocalhost,127.0.0.1,172.16.0.0/17,172.16.128.0/17,10.0.0.0/8,.example.dev"
        }
      },
      "required": []
    },
    "Spec.Kubernetes.LoadBalancers": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to true to install HAProxy and configure it as a load balancer on the the load balancer hosts."
        },
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Host"
          }
        },
        "keepalived": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Keepalived"
        },
        "stats": {
          "$ref": "#/$defs/Spec.Kubernetes.LoadBalancers.Stats"
        },
        "additionalConfig": {
          "type": "string",
          "description": "Additional configuration to append to HAProxy's configuration file."
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "hosts",
          "keepalived",
          "stats"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the host (not the hostname or FQDN)."
        },
        "ip": {
          "type": "string",
          "description": "The IP address of the host."
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.LoadBalancers.Keepalived": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Set to install keepalived with a floating virtual IP shared between the load balancer hosts for a deployment in High Availability."
        },
        "interface": {
          "type": "string",
          "description": "Name of the network interface where to bind the Keepalived virtual IP."
        },
        "ip": {
          "type": "string",
          "description": "The Virtual floating IP for Keepalived"
        },
        "virtualRouterId": {
          "type": "string",
          "description": "The virtual router ID of Keepalived, must be different from other Keepalived instances in the same network."
        },
        "passphrase": {
          "type": "string",
          "description": "The passphrase for the Keepalived clustering."
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "interface",
          "ip",
          "virtualRouterId",
          "passphrase"
        ]
      }
    },
    "Spec.Kubernetes.LoadBalancers.Stats": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for HAProxy stats page. Accessible at http://<haproxy host>:1936/stats",
      "properties": {
        "username": {
          "type": "string",
          "description": "The basic-auth username for HAProxy's stats page"
        },
        "password": {
          "type": "string",
          "description": "The basic-auth password for HAProxy's stats page."
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Kubernetes.Masters": {
      "type": "object",
      "description": "Configuration for the control plane hosts",
      "additionalProperties": false,
      "properties": {
        "hosts": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Masters.Host"
          }
        }
      },
      "required": [
        "hosts"
      ]
    },
    "Spec.Kubernetes.Masters.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "A name to identify the host (not the hostname or FQDN)"
        },
        "ip": {
          "type": "string",
          "description": "The IP address of the host"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.Nodes": {
      "type": "array",
      "description": "Configuration for the node hosts",
      "minItems": 1,
      "items": {
        "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node"
      }
    },
    "Spec.Kubernetes.Nodes.Node": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "type": "string",
          "description": "Name for the node group. It will be also used as the node role label. It should follow the [valid variable names guideline](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html#valid-variable-names) from Ansible."
        },
        "hosts": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/Spec.Kubernetes.Nodes.Node.Host"
          }
        },
        "taints": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeTaints"
          }
        }
      },
      "required": [
        "name",
        "hosts"
      ]
    },
    "Spec.Kubernetes.Nodes.Node.Host": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "name": {
          "description": "A name to identify the host (not the hostname or FQDN)",
          "type": "string"
        },
        "ip": {
          "description": "The IP address of the host",
          "type": "string"
        }
      },
      "required": [
        "name",
        "ip"
      ]
    },
    "Spec.Kubernetes.AdvancedAnsible": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "pythonInterpreter": {
          "type": "string",
          "description": "The Python interpreter to use for running Ansible. Example: python3"
        },
        "config": {
          "type": "string",
          "description": "Additional configuration to append to the ansible.cfg file"
        }
      }
    },
    "Spec.Kubernetes.Advanced": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cloud": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Cloud"
        },
        "users": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Users"
        },
        "oidc": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.OIDC"
        },
        "containerd": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd"
        },
        "encryption": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Encryption"
        },
        "airGap": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.AirGap"
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Kubernetes phase. (Default is registry.sighup.io/fury/on-premises)."
        }
      }
    },
    "Spec.Kubernetes.Advanced.Cloud": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "description": "Sets the cloud provider for the Kubelet"
        },
        "config": {
          "type": "string",
          "description": "Sets cloud config for the Kubelet"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Users": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of user names to create and get a kubeconfig file. Users will not have any permissions by default, RBAC setup for the new users is needed."
        },
        "org": {
          "type": "string",
          "description": "The organization the users belong to."
        }
      }
    },
    "Spec.Kubernetes.Advanced.OIDC": {
      "type": "object",
      "additionalProperties": false,
      "description": "OIDC configuration for the Kubernetes API server.",
      "properties": {
        "issuer_url": {
          "type": "string",
          "description": "The issuer URL of the OIDC provider."
        },
        "client_id": {
          "type": "string",
          "description": "The client ID the API server will use to authenticate to the OIDC provider."
        },
        "ca_file": {
          "type": "string",
          "description": "The path to the certificate for the CA that signed the identity provider's web certificate. Defaults to the host's root CAs. This should be a path available to the API Server."
        },
        "username_claim": {
          "type": "string",
          "description": "JWT claim to use as the user name. The default value is `sub`, which is expected to be a unique identifier of the end user."
        },
        "username_prefix": {
          "type": "string",
          "description": "Prefix prepended to username claims to prevent clashes with existing names (such as system: users)."
        },
        "groups_claim": {
          "type": "string",
          "description": "JWT claim to use as the user's group."
        },
        "group_prefix": {
          "type": "string",
          "description": "Prefix prepended to group claims to prevent clashes with existing names (such as system: groups)."
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd": {
      "type": "object",
      "additionalProperties": false,
      "description": "Advanced configuration for containerd",
      "properties": {
        "registryConfigs": {
          "$ref": "#/$defs/Spec.Kubernetes.Advanced.Containerd.RegistryConfigs"
        }
      }
    },
    "Spec.Kubernetes.Advanced.Containerd.RegistryConfigs": {
      "description": "Allows specifying custom configuration for a registry at containerd level. You can set authentication details and mirrors for a registry.\nThis feature can be used for example to authenticate to a private registry at containerd (container runtime) level, i.e. globally instead of using `imagePullSecrets`. It also can be used to use a mirror for a registry or to enable insecure connections to trusted registries that have self-signed certificates.",
      "type": "array",
      "additionalProperties": false,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "registry": {
            "type": "string",
            "description": "Registry address on which you would like to configure authentication or mirror(s). Example: `myregistry.tld:5000`"
          },
          "username": {
            "type": "string",
            "description": "The username containerd will use to authenticate against the registry."
          },
          "password": {
            "type": "string",
            "description": "The password containerd will use to authenticate against the registry."
          },
          "insecureSkipVerify": {
            "type": "boolean",
            "description": "Set to `true` to skip TLS verification (e.g. when using self-signed certificates)."
          },
          "mirrorEndpoint": {
            "type": "array",
            "description": "Array of URLs with the mirrors to use for the registry. Example: `[\"http://mymirror.tld:8080\"]`",
            "items": {
              "type": "string"
            }
          }
        }
      }
    },
    "Spec.Kubernetes.Advanced.Encryption": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "tlsCipherSuites": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The TLS cipher suites to use for etcd, kubelet, and kubeadm static pods. Example:\n```yaml\ntlsCipherSuites:\n  - \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\"\n  - \"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\"\n  - \"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\"\n  - \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\"\n  - \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\"\n  - \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\"\n  - \"TLS_AES_128_GCM_SHA256\"\n  - \"TLS_AES_256_GCM_SHA384\"\n  - \"TLS_CHACHA20_POLY1305_SHA256\"\n```"
        },
        "configuration": {
          "type": "string",
          "description": "etcd's encryption at rest configuration. Must be a string with the EncryptionConfiguration object in YAML. Example:\n\n```yaml\n\napiVersion: apiserver.config.k8s.io/v1\nkind: EncryptionConfiguration\nresources:\n  - resources:\n    - secrets\n    providers:\n    - aescbc:\n        keys:\n        - name: mykey\n          secret: base64_encoded_secret\n```\n"
        }
      }
    },
    "Spec.Kubernetes.Advanced.AirGap": {
      "type": "object",
      "description": "Advanced configuration for air-gapped installations. Allows setting custom URLs where to download the binaries dependencies from and custom .deb and .rpm package repositories.",
      "additionalProperties": false,
      "properties": {
        "containerdDownloadUrl": {
          "type": "string",
          "description": "URL where to download the containerd binary from."
        },
        "runcDownloadUrl": {
          "type": "string",
          "description": "URL where to download the runc binary from."
        },
        "runcChecksum": {
          "type": "string",
          "description": "Checksum for the runc binary."
        },
        "etcdDownloadUrl": {
          "type": "string",
          "description": "URL where to download the etcd binary from."
        },
        "dependenciesOverride": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "apt": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "An indicative name for the Apt repository. Example: `k8s-1.29`"
                },
                "repo": {
                  "type": "string",
                  "description": "A source string for the new Apt repository. Example: `deb https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /`"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "URL where to download the GPG key of the Apt repository. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key`"
                },
                "gpg_key_id": {
                  "type": "string",
                  "description": "The GPG key ID of the Apt repository. Example: `36A1D7869245C8950F966E92D8576A8BA88D21E9`"
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_id"
              ]
            },
            "yum": {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "An indicative name for the Yum repository. Example: `k8s-1.29`"
                },
                "repo": {
                  "type": "string",
                  "description": "URL to the directory where the Yum repository's `repodata` directory lives. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/rpm/`"
                },
                "gpg_key": {
                  "type": "string",
                  "description": "URL where to download the ASCII-armored GPG key of the Yum repository. Example: `https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key`"
                },
                "gpg_key_check": {
                  "type": "boolean",
                  "description": "If true, the GPG signature check on the packages will be enabled."
                },
                "repo_gpg_check": {
                  "type": "boolean",
                  "description": "If true, the GPG signature check on the `repodata` will be enabled."
                }
              },
              "required": [
                "name",
                "repo",
                "gpg_key",
                "gpg_key_check",
                "repo_gpg_check"
              ]
            }
          }
        }
      }
    },
    "Spec.Distribution": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "common": {
          "$ref": "#/$defs/Spec.Distribution.Common"
        },
        "modules": {
          "$ref": "#/$defs/Spec.Distribution.Modules"
        },
        "customPatches": {
          "$ref": "../public/spec-distribution-custompatches.json"
        }
      },
      "required": [
        "modules"
      ],
      "if": {
        "allOf": [
          {
            "required": [
              "common"
            ]
          },
          {
            "properties": {
              "common": {
                "required": [
                  "provider"
                ]
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "required": [
                      "type"
                    ]
                  }
                }
              }
            }
          },
          {
            "properties": {
              "common": {
                "properties": {
                  "provider": {
                    "properties": {
                      "type": {
                        "const": "eks"
                      }
                    }
                  }
                }
              }
            }
          }
        ]
      }
    },
    "Spec.Distribution.Common": {
      "type": "object",
      "additionalProperties": false,
      "description": "Common configuration for all the distribution modules.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "The node selector to use to place the pods for all the KFD modules. Follows Kubernetes selector format. Example: `node.kubernetes.io/role: infra`"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "An array with the tolerations that will be added to the pods for all the KFD modules. Follows Kubernetes tolerations format. Example:\n\n```yaml\n- effect: NoSchedule\n  key: node.kubernetes.io/role\n  value: infra\n```"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Common.Provider"
        },
        "relativeVendorPath": {
          "type": "string",
          "description": "The relative path to the vendor directory, does not need to be changed."
        },
        "registry": {
          "type": "string",
          "description": "URL of the registry where to pull images from for the Distribution phase. (Default is `registry.sighup.io/fury`)."
        }
      }
    },
    "Spec.Distribution.Common.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "description": "The provider type. Don't set. FOR INTERNAL USE ONLY."
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "auth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth"
        },
        "dr": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr"
        },
        "ingress": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress"
        },
        "logging": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging"
        },
        "monitoring": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring"
        },
        "tracing": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing"
        },
        "networking": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking"
        },
        "policy": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy"
        }
      },
      "required": [
        "dr",
        "ingress",
        "logging",
        "policy"
      ]
    },
    "Spec.Distribution.Modules.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides"
        },
        "baseDomain": {
          "type": "string",
          "description": "The base domain used for all the KFD infrastructural ingresses. If using the nginx dual type, this value should be the same as the domain associated with the `internal` ingress class."
        },
        "nginx": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx",
          "description": "Configurations for the nginx ingress controller package."
        },
        "certManager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager",
          "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses."
        },
        "forecastle": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Forecastle"
        },
        "if": {
          "properties": {
            "nginx": {
              "properties": {
                "tls": {
                  "properties": {
                    "provider": {
                      "const": "certManager"
                    }
                  }
                }
              }
            }
          }
        },
        "then": {
          "required": [
            "certManager"
          ]
        }
      },
      "required": [
        "baseDomain",
        "nginx"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Ingress module.",
      "properties": {
        "ingresses": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Overrides.Ingresses"
        },
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Ingress module"
        },
        "tolerations": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Ingress module"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Overrides.Ingresses": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "forecastle": {
          "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Forecastle": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "single",
            "dual"
          ],
          "description": "The type of the nginx ingress controller, options are:\n- `none`: no ingress controller will be installed and no infrastructural ingresses will be created.\n- `single`: a single ingress controller with ingress class `nginx` will be installed to manage all the ingress resources, infrastructural ingresses will be created.\n- `dual`: two independent ingress controllers will be installed, one for the `internal` ingress class intended for private ingresses and one for the `external` ingress class intended for public ingresses. KFD infrastructural ingresses wil use the `internal` ingress class when using the dual type."
        },
        "tls": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "provider": {
          "type": "string",
          "enum": [
            "certManager",
            "secret",
            "none"
          ],
          "description": "The provider of the TLS certificates for the ingresses, one of: `none`, `certManager`, or `secret`."
        },
        "secret": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret"
        }
      },
      "required": [
        "provider"
      ],
      "if": {
        "properties": {
          "provider": {
            "const": "secret"
          }
        }
      },
      "then": {
        "required": [
          "secret"
        ]
      }
    },
    "Spec.Distribution.Modules.Ingress.Nginx.TLS.Secret": {
      "type": "object",
      "additionalProperties": false,
      "description": "Kubernetes TLS secret for the ingresses TLS certificate.",
      "properties": {
        "cert": {
          "type": "string",
          "description": "The certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "key": {
          "type": "string",
          "description": "The signing key file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        },
        "ca": {
          "type": "string",
          "description": "The Certificate Authority certificate file's content. You can use the `\"{file://<path>}\"` notation to get the content from a file."
        }
      },
      "required": [
        "ca",
        "cert",
        "key"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager package. Required even if `ingress.nginx.type` is `none`, cert-manager is used for managing other certificates in the cluster besides the TLS termination certificates for the ingresses.",
      "properties": {
        "clusterIssuer": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer"
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "clusterIssuer"
      ]
    },
    "Spec.Distribution.Modules.Ingress.CertManager.ClusterIssuer": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the cert-manager's ACME clusterIssuer used to request certificates from Let's Encrypt.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the clusterIssuer"
        },
        "email": {
          "type": "string",
          "format": "email",
          "description": "The email address to use during the certificate issuing process."
        },
        "type": {
          "type": "string",
          "enum": [
            "http01"
          ],
          "description": "The type of the clusterIssuer. Only `http01` challenge is supported for on-premises clusters. See solvers for arbitrary configurations."
        },
        "solvers": {
          "type": "array",
          "description": "List of challenge solvers to use instead of the default one for the `http01` challenge."
        }
      },
      "required": [
        "name",
        "email"
      ],
      "oneOf": [
        {
          "required": [
            "type"
          ]
        },
        {
          "required": [
            "solvers"
          ]
        }
      ]
    },
    "Spec.Distribution.Modules.Logging": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "opensearch",
            "loki",
            "customOutputs"
          ],
          "description": "Selects the logging stack. Options are:\n- `none`: will disable the centralized logging.\n- `opensearch`: will deploy and configure the Logging Operator and an OpenSearch cluster (can be single or triple for HA) where the logs will be stored.\n- `loki`: will use a distributed Grafana Loki instead of OpenSearh for storage.\n- `customOuputs`: the Logging Operator will be deployed and installed but with no local storage, you will have to create the needed Outputs and ClusterOutputs to ship the logs to your desired storage."
        },
        "opensearch": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Opensearch"
        },
        "loki": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Loki"
        },
        "cerebro": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Cerebro"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Minio"
        },
        "operator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.Operator"
        },
        "customOutputs": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Logging.CustomOutputs"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "opensearch"
              }
            }
          },
          "then": {
            "required": [
              "opensearch"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "customOutputs"
              }
            }
          },
          "then": {
            "required": [
              "customOutputs"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Logging.Opensearch": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "single",
            "triple"
          ],
          "description": "The type of OpenSearch deployment. One of: `single` for a single replica or `triple` for an HA 3-replicas deployment."
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the OpenSearch volumes."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Logging.Cerebro": {
      "type": "object",
      "description": "DEPRECATED in latest versions of KFD.",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Minio": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for Logging's MinIO deployment.",
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Loki": {
      "type": "object",
      "description": "Configuration for the Loki package.",
      "additionalProperties": false,
      "properties": {
        "backend": {
          "type": "string",
          "description": "The storage backend type for Loki. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external object storage instead of deploying an in-cluster MinIO.",
          "enum": [
            "minio",
            "externalEndpoint"
          ]
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Loki's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Loki's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.Operator": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Logging Operator.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Logging.CustomOutputs": {
      "description": "When using the `customOutputs` logging type, you need to manually specify the spec of the several `Output` and `ClusterOutputs` that the Logging Operator expects to forward the logs collected by the pre-defined flows.",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "audit": {
          "type": "string",
          "description": "This value defines where the output from the `audit` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "events": {
          "type": "string",
          "description": "This value defines where the output from the `events` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "infra": {
          "type": "string",
          "description": "This value defines where the output from the `infra` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "ingressNginx": {
          "type": "string",
          "description": "This value defines where the output from the `ingressNginx` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "kubernetes": {
          "type": "string",
          "description": "This value defines where the output from the `kubernetes` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdCommon": {
          "type": "string",
          "description": "This value defines where the output from the `systemdCommon` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "systemdEtcd": {
          "type": "string",
          "description": "This value defines where the output from the `systemdEtcd` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        },
        "errors": {
          "type": "string",
          "description": "This value defines where the output from the `errors` Flow will be sent. This will be the `spec` section of the `Output` object. It must be a string (and not a YAML object) following the OutputSpec definition. Use the `nullout` output to discard the flow: `nullout: {}`"
        }
      },
      "required": [
        "audit",
        "events",
        "infra",
        "ingressNginx",
        "kubernetes",
        "systemdCommon",
        "systemdEtcd",
        "errors"
      ]
    },
    "Spec.Distribution.Modules.Monitoring": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Monitoring module.",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "prometheus",
            "prometheusAgent",
            "mimir"
          ],
          "description": "The type of the monitoring, must be `none`, `prometheus`, `prometheusAgent` or `mimir`.\n\n- `none`: will disable the whole monitoring stack.\n- `prometheus`: will install Prometheus Operator and a preconfigured Prometheus instace, Alertmanager, a set of alert rules, exporters needed to monitor all the components of the cluster, Grafana and a series of dashboards to view the collected metrics, and more.\n- `prometheusAgent`: wil install Prometheus operator, an instance of Prometheus in Agent mode (no alerting, no queries, no storage), and all the exporters needed to get metrics for the status of the cluster and the workloads. Useful when having a centralized (remote) Prometheus where to ship the metrics and not storing them locally in the cluster.\n- `mimir`: will install the same as the `prometheus` option, plus Grafana Mimir that allows for longer retention of metrics and the usage of Object Storage."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "prometheus": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Prometheus"
        },
        "prometheusAgent": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.PrometheusAgent"
        },
        "alertmanager": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.AlertManager"
        },
        "grafana": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Grafana"
        },
        "blackboxExporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.BlackboxExporter"
        },
        "kubeStateMetrics": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.KubeStateMetrics"
        },
        "x509Exporter": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.X509Exporter"
        },
        "mimir": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Mimir"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Monitoring.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Monitoring.Prometheus": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the `k8s` Prometheus instance."
        },
        "retentionSize": {
          "type": "string",
          "description": "The retention size for the `k8s` Prometheus instance."
        },
        "storageSize": {
          "type": "string",
          "description": "The storage size for the `k8s` Prometheus instance."
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.PrometheusAgent": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "resources": {
          "$ref": "#/$defs/Types.KubeResources"
        },
        "remoteWrite": {
          "description": "Set this option to ship the collected metrics to a remote Prometheus receiver.\n\n`remoteWrite` is an array of objects that allows configuring the [remoteWrite](https://prometheus.io/docs/specs/remote_write_spec/) options for Prometheus. The objects in the array follow [the same schema as in the prometheus operator](https://prometheus-operator.dev/docs/operator/api/#monitoring.coreos.com/v1.RemoteWriteSpec).",
          "type": "array",
          "items": {
            "type": "object"
          }
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.AlertManager": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "deadManSwitchWebhookUrl": {
          "type": "string",
          "description": "The webhook URL to send dead man's switch monitoring, for example to use with healthchecks.io"
        },
        "installDefaultRules": {
          "type": "boolean",
          "description": "Set to false to avoid installing the Prometheus rules (alerts) included with the distribution."
        },
        "slackWebhookUrl": {
          "type": "string",
          "description": "The Slack webhook URL where to send the infrastructural and workload alerts to."
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Grafana": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "usersRoleAttributePath": {
          "type": "string",
          "description": "[JMESPath](http://jmespath.org/examples.html) expression to retrieve the user's role. Example:\n\n```yaml\nusersRoleAttributePath: \"contains(groups[*], 'beta') && 'Admin' || contains(groups[*], 'gamma') && 'Editor' || contains(groups[*], 'delta') && 'Viewer'\n```\n\nMore details in [Grafana's documentation](https://grafana.com/docs/grafana/latest/setup-grafana/configure-security/configure-authentication/generic-oauth/#configure-role-mapping)."
        },
        "basicAuthIngress": {
          "type": "boolean",
          "description": "Setting this to true will deploy an additional `grafana-basic-auth` ingress protected with Grafana's basic auth instead of SSO. It's intended use is as a temporary ingress for when there are problems with the SSO login flow.\n\nNotice that by default anonymous access is enabled."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.BlackboxExporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.KubeStateMetrics": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.X509Exporter": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Mimir": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Mimir package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the logs stored in Mimir."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Mimir. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Mimir's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Mimir's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Monitoring.Minio": {
      "type": "object",
      "description": "Configuration for Monitoring's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tracing module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "tempo"
          ],
          "description": "The type of tracing to use, either `none` or `tempo`. `none` will disable the Tracing module and `tempo` will install a Grafana Tempo deployment."
        },
        "tempo": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Tempo"
        },
        "minio": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Tracing.Minio"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Tracing.Tempo": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Tempo package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "The retention time for the traces stored in Tempo."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Tempo. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "description": "Configuration for Tempo's external storage backend.",
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Tempo's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Tracing.Minio": {
      "type": "object",
      "description": "Configuration for Tracing's MinIO deployment.",
      "additionalProperties": false,
      "properties": {
        "storageSize": {
          "type": "string",
          "description": "The PVC size for each MinIO disk, 6 disks total."
        },
        "rootUser": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "username": {
              "type": "string",
              "description": "The username for the default MinIO root user."
            },
            "password": {
              "type": "string",
              "description": "The password for the default MinIO root user."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Networking module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "tigeraOperator": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.TigeraOperator"
        },
        "cilium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Networking.Cilium"
        },
        "type": {
          "type": "string",
          "enum": [
            "calico",
            "cilium"
          ],
          "description": "The type of CNI plugin to use, either `calico` (default, via the Tigera Operator) or `cilium`."
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Networking.TigeraOperator": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Networking.Cilium": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "podCidr": {
          "$ref": "#/$defs/Types.Cidr",
          "description": "FIXME: The CIDR for the Pods network. Set if must be different from `.spec.kubernetes.podCidr`."
        },
        "maskSize": {
          "type": "string",
          "description": "The mask size to use for the Pods network on each node."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Policy": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Policy module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "gatekeeper",
            "kyverno"
          ],
          "description": "The type of policy enforcement to use, either `none`, `gatekeeper` or `kyverno`."
        },
        "gatekeeper": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Gatekeeper"
        },
        "kyverno": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Policy.Kyverno"
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "gatekeeper"
              }
            }
          },
          "then": {
            "required": [
              "gatekeeper"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "kyverno"
              }
            }
          },
          "then": {
            "required": [
              "kyverno"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Policy.Gatekeeper": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Gatekeeper package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Gatekeeper's exemption list, so it will not enforce the constraints on them."
        },
        "enforcementAction": {
          "type": "string",
          "enum": [
            "deny",
            "dryrun",
            "warn"
          ],
          "description": "The default enforcement action to use for the included constraints. `deny` will block the admission when violations to the policies are found, `warn` will show a message to the user but will admit the violating requests and `dryrun` won't give any feedback to the user but it will log the violations."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Gatekeeper policies (constraints templates and constraints) included with the distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "enforcementAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Policy.Kyverno": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Kyverno package.",
      "properties": {
        "additionalExcludedNamespaces": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "This parameter adds namespaces to Kyverno's exemption list, so it will not enforce the policies on them."
        },
        "validationFailureAction": {
          "type": "string",
          "enum": [
            "audit",
            "enforce"
          ],
          "description": "The validation failure action to use for the policies, `enforce` will block when a request does not comply with the policies and `audit` will not block but log when a request does not comply with the policies."
        },
        "installDefaultPolicies": {
          "type": "boolean",
          "description": "Set to `false` to avoid installing the default Kyverno policies included with distribution."
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "validationFailureAction",
        "installDefaultPolicies"
      ]
    },
    "Spec.Distribution.Modules.Dr": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Disaster Recovery module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleOverrides"
        },
        "type": {
          "type": "string",
          "enum": [
            "none",
            "on-premises"
          ],
          "description": "The type of the Disaster Recovery, must be `none` or `on-premises`. `none` disables the module and `on-premises` will install Velero and an optional MinIO deployment."
        },
        "velero": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Dr.Velero"
        }
      },
      "required": [
        "type"
      ],
      "if": {
        "properties": {
          "type": {
            "const": "on-premises"
          }
        }
      },
      "then": {
        "required": [
          "type",
          "velero"
        ]
      }
    },
    "Spec.Distribution.Modules.Dr.Velero": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Velero package.",
      "properties": {
        "retentionTime": {
          "type": "string",
          "description": "CURRENTLY NOT IN USE."
        },
        "backend": {
          "type": "string",
          "enum": [
            "minio",
            "externalEndpoint"
          ],
          "description": "The storage backend type for Velero. `minio` will use an in-cluster MinIO deployment for object storage, `externalEndpoint` can be used to point to an external S3-compatible object storage instead of deploying an in-cluster MinIO."
        },
        "externalEndpoint": {
          "type": "object",
          "additionalProperties": false,
          "description": "Configuration for Velero's external storage backend.",
          "properties": {
            "endpoint": {
              "type": "string",
              "description": "External S3-compatible endpoint for Velero's storage."
            },
            "insecure": {
              "type": "boolean",
              "description": "If true, will use HTTP as protocol instead of HTTPS."
            },
            "secretAccessKey": {
              "type": "string",
              "description": "The secret access key (password) for the external S3-compatible bucket."
            },
            "accessKeyId": {
              "type": "string",
              "description": "The access key ID (username) for the external S3-compatible bucket."
            },
            "bucketName": {
              "type": "string",
              "description": "The bucket name of the external S3-compatible object storage."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      }
    },
    "Spec.Distribution.Modules.Auth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Auth module.",
      "properties": {
        "overrides": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides"
        },
        "provider": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider"
        },
        "baseDomain": {
          "type": "string",
          "description": "CURRENTLY NOT IN USE."
        },
        "pomerium": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Pomerium"
        },
        "dex": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Dex"
        },
        "oidcKubernetesAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.OIDCKubernetesAuth"
        }
      },
      "required": [
        "provider"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "sso"
                  }
                }
              }
            }
          },
          "then": {
            "required": [
              "dex",
              "pomerium",
              "baseDomain"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "provider": {
                "properties": {
                  "type": {
                    "const": "basicAuth"
                  }
                }
              }
            }
          },
          "then": {
            "properties": {
              "provider": {
                "required": [
                  "basicAuth"
                ]
              }
            }
          }
        },
        {
          "allOf": [
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "type": "object"
                  }
                }
              }
            },
            {
              "if": {
                "properties": {
                  "oidcKubernetesAuth": {
                    "properties": {
                      "enabled": {
                        "const": true
                      }
                    }
                  }
                }
              }
            }
          ],
          "then": {
            "required": [
              "baseDomain",
              "dex"
            ]
          }
        }
      ]
    },
    "Spec.Distribution.Modules.Auth.Overrides": {
      "type": "object",
      "additionalProperties": false,
      "description": "Override the common configuration with a particular configuration for the Auth module.",
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the Auth module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the Auth module."
        },
        "ingresses": {
          "additionalProperties": false,
          "type": "object",
          "description": "Override the definition of the Auth module ingresses.",
          "properties": {
            "gangplank": {
              "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
            },
            "dex": {
              "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Overrides.Ingress"
            }
          }
        }
      }
    },
    "Spec.Distribution.Modules.Auth.Overrides.Ingress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      },
      "required": [
        "host",
        "ingressClass"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "none",
            "basicAuth",
            "sso"
          ],
          "description": "The type of the Auth provider, options are:\n- `none`: will disable authentication in the infrastructural ingresses.\n- `sso`: will protect the infrastructural ingresses with Pomerium and Dex (SSO) and require authentication before accessing them.\n- `basicAuth`: will protect the infrastructural ingresses with HTTP basic auth (username and password) authentication."
        },
        "basicAuth": {
          "$ref": "#/$defs/Spec.Distribution.Modules.Auth.Provider.BasicAuth"
        }
      },
      "required": [
        "type"
      ]
    },
    "Spec.Distribution.Modules.Auth.Provider.BasicAuth": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the HTTP Basic Auth provider.",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username for logging in with the HTTP basic authentication."
        },
        "password": {
          "type": "string",
          "description": "The password for logging in with the HTTP basic authentication."
        }
      },
      "required": [
        "username",
        "password"
      ]
    },
    "Spec.Distribution.Modules.Auth.Pomerium": {
      "$ref": "./spec-distribution-modules-auth-pomerium.json"
    },
    "Spec.Distribution.Modules.Auth.Dex": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for the Dex package.",
      "properties": {
        "connectors": {
          "type": "array",
          "description": "A list with each item defining a Dex connector. Follows Dex connectors configuration format: https://dexidp.io/docs/connectors/"
        },
        "additionalStaticClients": {
          "type": "array",
          "description": "Additional static clients defitions that will be added to the default clients included with the distribution in Dex's configuration. Example:\n\n```yaml\nadditionalStaticClients:\n  - id: my-custom-client\n    name: \"A custom additional static client\"\n    redirectURIs:\n      - \"https://myapp.tld/redirect\"\n      - \"https://alias.tld/oidc-callback\"\n    secret: supersecretpassword\n```\nReference: https://dexidp.io/docs/connectors/local/"
        },
        "expiry": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "signingKeys": {
              "type": "string",
              "description": "Dex signing key expiration time duration (default 6h)."
            },
            "idTokens": {
              "type": "string",
              "description": "Dex ID tokens expiration time duration (default 24h)."
            }
          }
        },
        "overrides": {
          "$ref": "#/$defs/Types.FuryModuleComponentOverrides"
        }
      },
      "required": [
        "connectors"
      ]
    },
    "Spec.Distribution.Modules.Auth.OIDCKubernetesAuth": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "If true, components needed for interacting with the Kubernetes API with OIDC authentication (Gangplank, Dex) be deployed and configued."
        },
        "clientID": {
          "type": "string",
          "description": "The client ID that the Kubernetes API will use to authenticate against the OIDC provider (Dex)."
        },
        "clientSecret": {
          "type": "string",
          "description": "The client secret that the Kubernetes API will use to authenticate against the OIDC provider (Dex)."
        },
        "scopes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Used to specify the scope of the requested Oauth authorization by Gangplank. Defaults to: `[\"openid\", \"profile\", \"email\", \"offline_access\", \"groups\"]`"
        },
        "usernameClaim": {
          "type": "string",
          "description": "The JWT claim to use as the username. This is used in Gangplank's UI. This is combined with the clusterName for the user portion of the kubeconfig. Defaults to `nickname`."
        },
        "emailClaim": {
          "type": "string",
          "description": "DEPRECATED. Defaults to `email`."
        },
        "sessionSecurityKey": {
          "type": "string",
          "description": "The Key to use for the sessions in Gangplank. Must be different between different instances of Gangplank."
        },
        "removeCAFromKubeconfig": {
          "type": "boolean",
          "description": "Set to true to remove the CA from the kubeconfig file generated by Gangplank."
        },
        "namespace": {
          "type": "string",
          "description": "The namespace to set in the context of the kubeconfig file generated by Gangplank. Defaults to `default`."
        }
      },
      "required": [
        "enabled"
      ],
      "if": {
        "properties": {
          "enabled": {
            "const": true
          }
        }
      },
      "then": {
        "required": [
          "clientID",
          "clientSecret",
          "sessionSecurityKey"
        ]
      }
    },
    "Types.SemVer": {
      "type": "string",
      "pattern": "^v?(?P<major>0|[1-9]\\d*)\\.(?P<minor>0|[1-9]\\d*)\\.(?P<patch>0|[1-9]\\d*)(?:-(?P<prerelease>(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    },
    "Types.IpAddress": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\b){4}$"
    },
    "Types.Cidr": {
      "type": "string",
      "pattern": "^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}\\/(3[0-2]|[1-2][0-9]|[0-9])$"
    },
    "Types.FileRef": {
      "type": "string",
      "pattern": "^\\{file\\:\\/\\/.+\\}$"
    },
    "Types.EnvRef": {
      "type": "string",
      "pattern": "\\{^env\\:\\/\\/.*\\}$"
    },
    "Types.TcpPort": {
      "type": "integer",
      "minimum": 0,
      "maximum": 65535
    },
    "Types.SshPubKey": {
      "type": "string",
      "pattern": "^ssh\\-(dsa|ecdsa|ecdsa-sk|ed25519|ed25519-sk|rsa)\\s+"
    },
    "Types.Uri": {
      "type": "string",
      "pattern": "^(http|https)\\:\\/\\/.+$"
    },
    "Types.KubeLabels": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeTaints": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      },
      "required": [
        "effect",
        "key",
        "value"
      ]
    },
    "Types.KubeNodeSelector": {
      "type": [
        "object",
        "null"
      ],
      "additionalProperties": {
        "type": "string"
      }
    },
    "Types.KubeToleration": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "effect": {
          "type": "string",
          "enum": [
            "NoSchedule",
            "PreferNoSchedule",
            "NoExecute"
          ]
        },
        "operator": {
          "type": "string",
          "enum": [
            "Exists",
            "Equal"
          ]
        },
        "key": {
          "type": "string",
          "description": "The key of the toleration"
        },
        "value": {
          "type": "string",
          "description": "The value of the toleration"
        }
      },
      "required": [
        "effect",
        "key"
      ],
      "anyOf": [
        {
          "required": [
            "operator"
          ]
        },
        {
          "required": [
            "value"
          ]
        }
      ]
    },
    "Types.KubeResources": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "requests": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu request for the loki pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory request for the prometheus pods"
            }
          }
        },
        "limits": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "cpu": {
              "type": "string",
              "description": "The cpu limit for the loki pods"
            },
            "memory": {
              "type": "string",
              "description": "The memory limit for the prometheus pods"
            }
          }
        }
      }
    },
    "Types.FuryModuleOverrides": {
      "type": "object",
      "description": "Override the common configuration with a particular configuration for the module.",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the module."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the module."
        },
        "ingresses": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Types.FuryModuleOverridesIngress"
          }
        }
      }
    },
    "Types.FuryModuleComponentOverrides": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "nodeSelector": {
          "$ref": "#/$defs/Types.KubeNodeSelector",
          "description": "Set to override the node selector used to place the pods of the package."
        },
        "tolerations": {
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/$defs/Types.KubeToleration"
          },
          "description": "Set to override the tolerations that will be added to the pods of the package."
        }
      }
    },
    "Types.FuryModuleOverridesIngress": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "disableAuth": {
          "type": "boolean",
          "description": "If true, the ingress will not have authentication even if `.spec.modules.auth.provider.type` is SSO or Basic Auth."
        },
        "host": {
          "type": "string",
          "description": "Use this host for the ingress instead of the default one."
        },
        "ingressClass": {
          "type": "string",
          "description": "Use this ingress class for the ingress instead of the default one."
        }
      }
    }
  }
}