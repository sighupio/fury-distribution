// Code generated by github.com/sighupio/go-jsonschema, DO NOT EDIT.

package public

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// A Fury Cluster deployed through AWS's Elastic Kubernetes Service
type EksclusterKfdV1Alpha2 struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion" yaml:"apiVersion" mapstructure:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind EksclusterKfdV1Alpha2Kind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata Metadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Spec corresponds to the JSON schema field "spec".
	Spec Spec `json:"spec" yaml:"spec" mapstructure:"spec"`
}

type EksclusterKfdV1Alpha2Kind string

const EksclusterKfdV1Alpha2KindEKSCluster EksclusterKfdV1Alpha2Kind = "EKSCluster"

type Metadata struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type Spec struct {
	// Distribution corresponds to the JSON schema field "distribution".
	Distribution SpecDistribution `json:"distribution" yaml:"distribution" mapstructure:"distribution"`

	// DistributionVersion corresponds to the JSON schema field "distributionVersion".
	DistributionVersion string `json:"distributionVersion" yaml:"distributionVersion" mapstructure:"distributionVersion"`

	// Infrastructure corresponds to the JSON schema field "infrastructure".
	Infrastructure *SpecInfrastructure `json:"infrastructure,omitempty" yaml:"infrastructure,omitempty" mapstructure:"infrastructure,omitempty"`

	// Kubernetes corresponds to the JSON schema field "kubernetes".
	Kubernetes SpecKubernetes `json:"kubernetes" yaml:"kubernetes" mapstructure:"kubernetes"`

	// Plugins corresponds to the JSON schema field "plugins".
	Plugins *SpecPlugins `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// Region corresponds to the JSON schema field "region".
	Region TypesAwsRegion `json:"region" yaml:"region" mapstructure:"region"`

	// This map defines which will be the common tags that will be added to all the
	// resources created on AWS.
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// ToolsConfiguration corresponds to the JSON schema field "toolsConfiguration".
	ToolsConfiguration SpecToolsConfiguration `json:"toolsConfiguration" yaml:"toolsConfiguration" mapstructure:"toolsConfiguration"`
}

type SpecDistribution struct {
	// Common corresponds to the JSON schema field "common".
	Common *SpecDistributionCommon `json:"common,omitempty" yaml:"common,omitempty" mapstructure:"common,omitempty"`

	// CustomPatches corresponds to the JSON schema field "customPatches".
	CustomPatches *SpecDistributionCustomPatches `json:"customPatches,omitempty" yaml:"customPatches,omitempty" mapstructure:"customPatches,omitempty"`

	// Modules corresponds to the JSON schema field "modules".
	Modules SpecDistributionModules `json:"modules" yaml:"modules" mapstructure:"modules"`
}

type SpecDistributionCommon struct {
	// The node selector to use to place the pods for all the KFD modules
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Provider corresponds to the JSON schema field "provider".
	Provider *SpecDistributionCommonProvider `json:"provider,omitempty" yaml:"provider,omitempty" mapstructure:"provider,omitempty"`

	// The relative path to the vendor directory, does not need to be changed
	RelativeVendorPath *string `json:"relativeVendorPath,omitempty" yaml:"relativeVendorPath,omitempty" mapstructure:"relativeVendorPath,omitempty"`

	// The tolerations that will be added to the pods for all the KFD modules
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

type SpecDistributionCommonProvider struct {
	// The type of the provider, must be EKS if specified
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionCustomPatches struct {
	// ConfigMapGenerator corresponds to the JSON schema field "configMapGenerator".
	ConfigMapGenerator SpecDistributionCustomPatchesConfigMapGenerator `json:"configMapGenerator,omitempty" yaml:"configMapGenerator,omitempty" mapstructure:"configMapGenerator,omitempty"`

	// Images corresponds to the JSON schema field "images".
	Images SpecDistributionCustomPatchesImages `json:"images,omitempty" yaml:"images,omitempty" mapstructure:"images,omitempty"`

	// Patches corresponds to the JSON schema field "patches".
	Patches SpecDistributionCustomPatchesPatches `json:"patches,omitempty" yaml:"patches,omitempty" mapstructure:"patches,omitempty"`

	// PatchesStrategicMerge corresponds to the JSON schema field
	// "patchesStrategicMerge".
	PatchesStrategicMerge SpecDistributionCustomPatchesPatchesStrategicMerge `json:"patchesStrategicMerge,omitempty" yaml:"patchesStrategicMerge,omitempty" mapstructure:"patchesStrategicMerge,omitempty"`

	// SecretGenerator corresponds to the JSON schema field "secretGenerator".
	SecretGenerator SpecDistributionCustomPatchesSecretGenerator `json:"secretGenerator,omitempty" yaml:"secretGenerator,omitempty" mapstructure:"secretGenerator,omitempty"`
}

type SpecDistributionCustomPatchesConfigMapGenerator []SpecDistributionCustomPatchesConfigMapGeneratorResource

type SpecDistributionCustomPatchesConfigMapGeneratorResource struct {
	// Behavior corresponds to the JSON schema field "behavior".
	Behavior *SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior `json:"behavior,omitempty" yaml:"behavior,omitempty" mapstructure:"behavior,omitempty"`

	// Envs corresponds to the JSON schema field "envs".
	Envs []string `json:"envs,omitempty" yaml:"envs,omitempty" mapstructure:"envs,omitempty"`

	// Files corresponds to the JSON schema field "files".
	Files []string `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

	// Literals corresponds to the JSON schema field "literals".
	Literals []string `json:"literals,omitempty" yaml:"literals,omitempty" mapstructure:"literals,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesConfigMapGeneratorResourceOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`
}

type SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior string

const (
	SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorCreate  SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "create"
	SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorMerge   SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "merge"
	SpecDistributionCustomPatchesConfigMapGeneratorResourceBehaviorReplace SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = "replace"
)

type SpecDistributionCustomPatchesConfigMapGeneratorResourceOptions struct {
	// Annotations corresponds to the JSON schema field "annotations".
	Annotations TypesKubeLabels `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// DisableNameSuffixHash corresponds to the JSON schema field
	// "disableNameSuffixHash".
	DisableNameSuffixHash *bool `json:"disableNameSuffixHash,omitempty" yaml:"disableNameSuffixHash,omitempty" mapstructure:"disableNameSuffixHash,omitempty"`

	// Immutable corresponds to the JSON schema field "immutable".
	Immutable *bool `json:"immutable,omitempty" yaml:"immutable,omitempty" mapstructure:"immutable,omitempty"`

	// Labels corresponds to the JSON schema field "labels".
	Labels TypesKubeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

type SpecDistributionCustomPatchesImages []map[string]interface{}

type SpecDistributionCustomPatchesPatch struct {
	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesPatchOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Patch corresponds to the JSON schema field "patch".
	Patch *string `json:"patch,omitempty" yaml:"patch,omitempty" mapstructure:"patch,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Target corresponds to the JSON schema field "target".
	Target *SpecDistributionCustomPatchesPatchTarget `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`
}

type SpecDistributionCustomPatchesPatchOptions struct {
	// AllowKindChange corresponds to the JSON schema field "allowKindChange".
	AllowKindChange *bool `json:"allowKindChange,omitempty" yaml:"allowKindChange,omitempty" mapstructure:"allowKindChange,omitempty"`

	// AllowNameChange corresponds to the JSON schema field "allowNameChange".
	AllowNameChange *bool `json:"allowNameChange,omitempty" yaml:"allowNameChange,omitempty" mapstructure:"allowNameChange,omitempty"`
}

type SpecDistributionCustomPatchesPatchTarget struct {
	// AnnotationSelector corresponds to the JSON schema field "annotationSelector".
	AnnotationSelector *string `json:"annotationSelector,omitempty" yaml:"annotationSelector,omitempty" mapstructure:"annotationSelector,omitempty"`

	// Group corresponds to the JSON schema field "group".
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// Kind corresponds to the JSON schema field "kind".
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *string `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type SpecDistributionCustomPatchesPatches []SpecDistributionCustomPatchesPatch

type SpecDistributionCustomPatchesPatchesStrategicMerge []string

type SpecDistributionCustomPatchesSecretGenerator []SpecDistributionCustomPatchesSecretGeneratorResource

type SpecDistributionCustomPatchesSecretGeneratorResource struct {
	// Behavior corresponds to the JSON schema field "behavior".
	Behavior *SpecDistributionCustomPatchesSecretGeneratorResourceBehavior `json:"behavior,omitempty" yaml:"behavior,omitempty" mapstructure:"behavior,omitempty"`

	// Envs corresponds to the JSON schema field "envs".
	Envs []string `json:"envs,omitempty" yaml:"envs,omitempty" mapstructure:"envs,omitempty"`

	// Files corresponds to the JSON schema field "files".
	Files []string `json:"files,omitempty" yaml:"files,omitempty" mapstructure:"files,omitempty"`

	// Literals corresponds to the JSON schema field "literals".
	Literals []string `json:"literals,omitempty" yaml:"literals,omitempty" mapstructure:"literals,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options *SpecDistributionCustomPatchesSecretGeneratorResourceOptions `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type SpecDistributionCustomPatchesSecretGeneratorResourceBehavior string

const (
	SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorCreate  SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "create"
	SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorMerge   SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "merge"
	SpecDistributionCustomPatchesSecretGeneratorResourceBehaviorReplace SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = "replace"
)

type SpecDistributionCustomPatchesSecretGeneratorResourceOptions struct {
	// Annotations corresponds to the JSON schema field "annotations".
	Annotations TypesKubeLabels `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// DisableNameSuffixHash corresponds to the JSON schema field
	// "disableNameSuffixHash".
	DisableNameSuffixHash *bool `json:"disableNameSuffixHash,omitempty" yaml:"disableNameSuffixHash,omitempty" mapstructure:"disableNameSuffixHash,omitempty"`

	// Immutable corresponds to the JSON schema field "immutable".
	Immutable *bool `json:"immutable,omitempty" yaml:"immutable,omitempty" mapstructure:"immutable,omitempty"`

	// Labels corresponds to the JSON schema field "labels".
	Labels TypesKubeLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

type SpecDistributionModules struct {
	// Auth corresponds to the JSON schema field "auth".
	Auth *SpecDistributionModulesAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Aws corresponds to the JSON schema field "aws".
	Aws *SpecDistributionModulesAws `json:"aws,omitempty" yaml:"aws,omitempty" mapstructure:"aws,omitempty"`

	// Dr corresponds to the JSON schema field "dr".
	Dr SpecDistributionModulesDr `json:"dr" yaml:"dr" mapstructure:"dr"`

	// Ingress corresponds to the JSON schema field "ingress".
	Ingress SpecDistributionModulesIngress `json:"ingress" yaml:"ingress" mapstructure:"ingress"`

	// Logging corresponds to the JSON schema field "logging".
	Logging SpecDistributionModulesLogging `json:"logging" yaml:"logging" mapstructure:"logging"`

	// Monitoring corresponds to the JSON schema field "monitoring".
	Monitoring *SpecDistributionModulesMonitoring `json:"monitoring,omitempty" yaml:"monitoring,omitempty" mapstructure:"monitoring,omitempty"`

	// Networking corresponds to the JSON schema field "networking".
	Networking *SpecDistributionModulesNetworking `json:"networking,omitempty" yaml:"networking,omitempty" mapstructure:"networking,omitempty"`

	// Policy corresponds to the JSON schema field "policy".
	Policy SpecDistributionModulesPolicy `json:"policy" yaml:"policy" mapstructure:"policy"`

	// Tracing corresponds to the JSON schema field "tracing".
	Tracing *SpecDistributionModulesTracing `json:"tracing,omitempty" yaml:"tracing,omitempty" mapstructure:"tracing,omitempty"`
}

type SpecDistributionModulesAuth struct {
	// The base domain for the auth module
	BaseDomain *string `json:"baseDomain,omitempty" yaml:"baseDomain,omitempty" mapstructure:"baseDomain,omitempty"`

	// Dex corresponds to the JSON schema field "dex".
	Dex *SpecDistributionModulesAuthDex `json:"dex,omitempty" yaml:"dex,omitempty" mapstructure:"dex,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *SpecDistributionModulesAuthOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Pomerium corresponds to the JSON schema field "pomerium".
	Pomerium *SpecDistributionModulesAuthPomerium `json:"pomerium,omitempty" yaml:"pomerium,omitempty" mapstructure:"pomerium,omitempty"`

	// Provider corresponds to the JSON schema field "provider".
	Provider SpecDistributionModulesAuthProvider `json:"provider" yaml:"provider" mapstructure:"provider"`
}

type SpecDistributionModulesAuthDex struct {
	// The additional static clients for dex
	AdditionalStaticClients []interface{} `json:"additionalStaticClients,omitempty" yaml:"additionalStaticClients,omitempty" mapstructure:"additionalStaticClients,omitempty"`

	// The connectors for dex
	Connectors []interface{} `json:"connectors" yaml:"connectors" mapstructure:"connectors"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesAuthOverrides struct {
	// Ingresses corresponds to the JSON schema field "ingresses".
	Ingresses SpecDistributionModulesAuthOverridesIngresses `json:"ingresses,omitempty" yaml:"ingresses,omitempty" mapstructure:"ingresses,omitempty"`

	// The node selector to use to place the pods for the auth module
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// The tolerations that will be added to the pods for the auth module
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

type SpecDistributionModulesAuthOverridesIngress struct {
	// The host of the ingress
	Host string `json:"host" yaml:"host" mapstructure:"host"`

	// The ingress class of the ingress
	IngressClass string `json:"ingressClass" yaml:"ingressClass" mapstructure:"ingressClass"`
}

type SpecDistributionModulesAuthOverridesIngresses map[string]SpecDistributionModulesAuthOverridesIngress

type SpecDistributionModulesAuthPomerium struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The policy for pomerium
	Policy string `json:"policy" yaml:"policy" mapstructure:"policy"`

	// Secrets corresponds to the JSON schema field "secrets".
	Secrets SpecDistributionModulesAuthPomeriumSecrets `json:"secrets" yaml:"secrets" mapstructure:"secrets"`
}

type SpecDistributionModulesAuthPomeriumSecrets struct {
	// The cookie secret for pomerium
	COOKIESECRET string `json:"COOKIE_SECRET" yaml:"COOKIE_SECRET" mapstructure:"COOKIE_SECRET"`

	// The IDP client secret for pomerium
	IDPCLIENTSECRET string `json:"IDP_CLIENT_SECRET" yaml:"IDP_CLIENT_SECRET" mapstructure:"IDP_CLIENT_SECRET"`

	// The shared secret for pomerium
	SHAREDSECRET string `json:"SHARED_SECRET" yaml:"SHARED_SECRET" mapstructure:"SHARED_SECRET"`
}

type SpecDistributionModulesAuthProvider struct {
	// BasicAuth corresponds to the JSON schema field "basicAuth".
	BasicAuth *SpecDistributionModulesAuthProviderBasicAuth `json:"basicAuth,omitempty" yaml:"basicAuth,omitempty" mapstructure:"basicAuth,omitempty"`

	// The type of the provider, must be ***none***, ***sso*** or ***basicAuth***
	Type SpecDistributionModulesAuthProviderType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesAuthProviderBasicAuth struct {
	// The password for the basic auth
	Password string `json:"password" yaml:"password" mapstructure:"password"`

	// The username for the basic auth
	Username string `json:"username" yaml:"username" mapstructure:"username"`
}

type SpecDistributionModulesAuthProviderType string

const (
	SpecDistributionModulesAuthProviderTypeBasicAuth SpecDistributionModulesAuthProviderType = "basicAuth"
	SpecDistributionModulesAuthProviderTypeNone      SpecDistributionModulesAuthProviderType = "none"
	SpecDistributionModulesAuthProviderTypeSso       SpecDistributionModulesAuthProviderType = "sso"
)

type SpecDistributionModulesAws struct {
	// ClusterAutoscaler corresponds to the JSON schema field "clusterAutoscaler".
	ClusterAutoscaler *SpecDistributionModulesAwsClusterAutoscaler `json:"clusterAutoscaler,omitempty" yaml:"clusterAutoscaler,omitempty" mapstructure:"clusterAutoscaler,omitempty"`

	// EbsCsiDriver corresponds to the JSON schema field "ebsCsiDriver".
	EbsCsiDriver *SpecDistributionModulesAwsEbsCsiDriver `json:"ebsCsiDriver,omitempty" yaml:"ebsCsiDriver,omitempty" mapstructure:"ebsCsiDriver,omitempty"`

	// EbsSnapshotController corresponds to the JSON schema field
	// "ebsSnapshotController".
	EbsSnapshotController *SpecDistributionModulesAwsEbsSnapshotController `json:"ebsSnapshotController,omitempty" yaml:"ebsSnapshotController,omitempty" mapstructure:"ebsSnapshotController,omitempty"`

	// LoadBalancerController corresponds to the JSON schema field
	// "loadBalancerController".
	LoadBalancerController *SpecDistributionModulesAwsLoadBalancerController `json:"loadBalancerController,omitempty" yaml:"loadBalancerController,omitempty" mapstructure:"loadBalancerController,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesAwsClusterAutoscaler struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverridesWithIAMRoleName `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesAwsEbsCsiDriver struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverridesWithIAMRoleName `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesAwsEbsSnapshotController struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesAwsLoadBalancerController struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverridesWithIAMRoleName `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesDr struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The type of the DR, must be ***none*** or ***eks***
	Type SpecDistributionModulesDrType `json:"type" yaml:"type" mapstructure:"type"`

	// Velero corresponds to the JSON schema field "velero".
	Velero *SpecDistributionModulesDrVelero `json:"velero,omitempty" yaml:"velero,omitempty" mapstructure:"velero,omitempty"`
}

type SpecDistributionModulesDrType string

const (
	SpecDistributionModulesDrTypeEks  SpecDistributionModulesDrType = "eks"
	SpecDistributionModulesDrTypeNone SpecDistributionModulesDrType = "none"
)

type SpecDistributionModulesDrVelero struct {
	// Eks corresponds to the JSON schema field "eks".
	Eks SpecDistributionModulesDrVeleroEks `json:"eks" yaml:"eks" mapstructure:"eks"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesDrVeleroEks struct {
	// The name of the velero bucket
	BucketName TypesAwsS3BucketName `json:"bucketName" yaml:"bucketName" mapstructure:"bucketName"`

	// The region where the velero bucket is located
	Region TypesAwsRegion `json:"region" yaml:"region" mapstructure:"region"`
}

type SpecDistributionModulesIngress struct {
	// the base domain used for all the KFD ingresses, if in the nginx dual
	// configuration, it should be the same as the
	// .spec.distribution.modules.ingress.dns.private.name zone
	BaseDomain string `json:"baseDomain" yaml:"baseDomain" mapstructure:"baseDomain"`

	// CertManager corresponds to the JSON schema field "certManager".
	CertManager *SpecDistributionModulesIngressCertManager `json:"certManager,omitempty" yaml:"certManager,omitempty" mapstructure:"certManager,omitempty"`

	// Dns corresponds to the JSON schema field "dns".
	Dns SpecDistributionModulesIngressDNS `json:"dns" yaml:"dns" mapstructure:"dns"`

	// Forecastle corresponds to the JSON schema field "forecastle".
	Forecastle *SpecDistributionModulesIngressForecastle `json:"forecastle,omitempty" yaml:"forecastle,omitempty" mapstructure:"forecastle,omitempty"`

	// Configurations for the nginx ingress controller module
	Nginx SpecDistributionModulesIngressNginx `json:"nginx" yaml:"nginx" mapstructure:"nginx"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *SpecDistributionModulesIngressOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesIngressCertManager struct {
	// ClusterIssuer corresponds to the JSON schema field "clusterIssuer".
	ClusterIssuer SpecDistributionModulesIngressCertManagerClusterIssuer `json:"clusterIssuer" yaml:"clusterIssuer" mapstructure:"clusterIssuer"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesIngressCertManagerClusterIssuer struct {
	// The email of the cluster issuer
	Email string `json:"email" yaml:"email" mapstructure:"email"`

	// The name of the cluster issuer
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// The custom solvers configurations
	Solvers []interface{} `json:"solvers,omitempty" yaml:"solvers,omitempty" mapstructure:"solvers,omitempty"`

	// The type of the cluster issuer, must be ***dns01*** or ***http01***
	Type *SpecDistributionModulesIngressCertManagerClusterIssuerType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type SpecDistributionModulesIngressCertManagerClusterIssuerType string

const (
	SpecDistributionModulesIngressCertManagerClusterIssuerTypeDns01  SpecDistributionModulesIngressCertManagerClusterIssuerType = "dns01"
	SpecDistributionModulesIngressCertManagerClusterIssuerTypeHttp01 SpecDistributionModulesIngressCertManagerClusterIssuerType = "http01"
)

type SpecDistributionModulesIngressDNS struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Private corresponds to the JSON schema field "private".
	Private SpecDistributionModulesIngressDNSPrivate `json:"private" yaml:"private" mapstructure:"private"`

	// Public corresponds to the JSON schema field "public".
	Public SpecDistributionModulesIngressDNSPublic `json:"public" yaml:"public" mapstructure:"public"`
}

type SpecDistributionModulesIngressDNSPrivate struct {
	// If true, the private hosted zone will be created
	Create bool `json:"create" yaml:"create" mapstructure:"create"`

	// The name of the private hosted zone
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SpecDistributionModulesIngressDNSPublic struct {
	// If true, the public hosted zone will be created
	Create bool `json:"create" yaml:"create" mapstructure:"create"`

	// The name of the public hosted zone
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SpecDistributionModulesIngressForecastle struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesIngressNginx struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Tls corresponds to the JSON schema field "tls".
	Tls *SpecDistributionModulesIngressNginxTLS `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// The type of the nginx ingress controller, must be ***none***, ***single*** or
	// ***dual***
	Type SpecDistributionModulesIngressNginxType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesIngressNginxTLS struct {
	// The provider of the TLS certificate, must be ***none***, ***certManager*** or
	// ***secret***
	Provider SpecDistributionModulesIngressNginxTLSProvider `json:"provider" yaml:"provider" mapstructure:"provider"`

	// Secret corresponds to the JSON schema field "secret".
	Secret *SpecDistributionModulesIngressNginxTLSSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

type SpecDistributionModulesIngressNginxTLSProvider string

const (
	SpecDistributionModulesIngressNginxTLSProviderCertManager SpecDistributionModulesIngressNginxTLSProvider = "certManager"
	SpecDistributionModulesIngressNginxTLSProviderNone        SpecDistributionModulesIngressNginxTLSProvider = "none"
	SpecDistributionModulesIngressNginxTLSProviderSecret      SpecDistributionModulesIngressNginxTLSProvider = "secret"
)

type SpecDistributionModulesIngressNginxTLSSecret struct {
	// Ca corresponds to the JSON schema field "ca".
	Ca string `json:"ca" yaml:"ca" mapstructure:"ca"`

	// The certificate file content or you can use the file notation to get the
	// content from a file
	Cert string `json:"cert" yaml:"cert" mapstructure:"cert"`

	// Key corresponds to the JSON schema field "key".
	Key string `json:"key" yaml:"key" mapstructure:"key"`
}

type SpecDistributionModulesIngressNginxType string

const (
	SpecDistributionModulesIngressNginxTypeDual   SpecDistributionModulesIngressNginxType = "dual"
	SpecDistributionModulesIngressNginxTypeNone   SpecDistributionModulesIngressNginxType = "none"
	SpecDistributionModulesIngressNginxTypeSingle SpecDistributionModulesIngressNginxType = "single"
)

type SpecDistributionModulesIngressOverrides struct {
	// Ingresses corresponds to the JSON schema field "ingresses".
	Ingresses *SpecDistributionModulesIngressOverridesIngresses `json:"ingresses,omitempty" yaml:"ingresses,omitempty" mapstructure:"ingresses,omitempty"`

	// The node selector to use to place the pods for the ingress module
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// The tolerations that will be added to the pods for the ingress module
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

type SpecDistributionModulesIngressOverridesIngresses struct {
	// Forecastle corresponds to the JSON schema field "forecastle".
	Forecastle *TypesFuryModuleOverridesIngress `json:"forecastle,omitempty" yaml:"forecastle,omitempty" mapstructure:"forecastle,omitempty"`
}

type SpecDistributionModulesLogging struct {
	// Cerebro corresponds to the JSON schema field "cerebro".
	Cerebro *SpecDistributionModulesLoggingCerebro `json:"cerebro,omitempty" yaml:"cerebro,omitempty" mapstructure:"cerebro,omitempty"`

	// Loki corresponds to the JSON schema field "loki".
	Loki *SpecDistributionModulesLoggingLoki `json:"loki,omitempty" yaml:"loki,omitempty" mapstructure:"loki,omitempty"`

	// Minio corresponds to the JSON schema field "minio".
	Minio *SpecDistributionModulesLoggingMinio `json:"minio,omitempty" yaml:"minio,omitempty" mapstructure:"minio,omitempty"`

	// Opensearch corresponds to the JSON schema field "opensearch".
	Opensearch *SpecDistributionModulesLoggingOpensearch `json:"opensearch,omitempty" yaml:"opensearch,omitempty" mapstructure:"opensearch,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *SpecDistributionModulesLoggingOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The type of the logging, must be ***none***, ***opensearch*** or ***loki***
	Type SpecDistributionModulesLoggingType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesLoggingCerebro struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesLoggingLoki struct {
	// Backend corresponds to the JSON schema field "backend".
	Backend *SpecDistributionModulesLoggingLokiBackend `json:"backend,omitempty" yaml:"backend,omitempty" mapstructure:"backend,omitempty"`

	// ExternalEndpoint corresponds to the JSON schema field "externalEndpoint".
	ExternalEndpoint *SpecDistributionModulesLoggingLokiExternalEndpoint `json:"externalEndpoint,omitempty" yaml:"externalEndpoint,omitempty" mapstructure:"externalEndpoint,omitempty"`

	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

type SpecDistributionModulesLoggingLokiBackend string

const (
	SpecDistributionModulesLoggingLokiBackendExternalEndpoint SpecDistributionModulesLoggingLokiBackend = "externalEndpoint"
	SpecDistributionModulesLoggingLokiBackendMinio            SpecDistributionModulesLoggingLokiBackend = "minio"
)

type SpecDistributionModulesLoggingLokiExternalEndpoint struct {
	// The access key id of the loki external endpoint
	AccessKeyId *string `json:"accessKeyId,omitempty" yaml:"accessKeyId,omitempty" mapstructure:"accessKeyId,omitempty"`

	// The bucket name of the loki external endpoint
	BucketName *string `json:"bucketName,omitempty" yaml:"bucketName,omitempty" mapstructure:"bucketName,omitempty"`

	// The endpoint of the loki external endpoint
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty" mapstructure:"endpoint,omitempty"`

	// If true, the loki external endpoint will be insecure
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// The secret access key of the loki external endpoint
	SecretAccessKey *string `json:"secretAccessKey,omitempty" yaml:"secretAccessKey,omitempty" mapstructure:"secretAccessKey,omitempty"`
}

type SpecDistributionModulesLoggingMinio struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// RootUser corresponds to the JSON schema field "rootUser".
	RootUser *SpecDistributionModulesLoggingMinioRootUser `json:"rootUser,omitempty" yaml:"rootUser,omitempty" mapstructure:"rootUser,omitempty"`

	// The PVC size for each minio disk, 6 disks total
	StorageSize *string `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesLoggingMinioRootUser struct {
	// The password of the minio root user
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// The username of the minio root user
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

type SpecDistributionModulesLoggingOpensearch struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// The storage size for the opensearch pods
	StorageSize *string `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`

	// The type of the opensearch, must be ***single*** or ***triple***
	Type SpecDistributionModulesLoggingOpensearchType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesLoggingOpensearchType string

const (
	SpecDistributionModulesLoggingOpensearchTypeSingle SpecDistributionModulesLoggingOpensearchType = "single"
	SpecDistributionModulesLoggingOpensearchTypeTriple SpecDistributionModulesLoggingOpensearchType = "triple"
)

type SpecDistributionModulesLoggingOperator struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesLoggingType string

const (
	SpecDistributionModulesLoggingTypeLoki       SpecDistributionModulesLoggingType = "loki"
	SpecDistributionModulesLoggingTypeNone       SpecDistributionModulesLoggingType = "none"
	SpecDistributionModulesLoggingTypeOpensearch SpecDistributionModulesLoggingType = "opensearch"
)

type SpecDistributionModulesMonitoring struct {
	// Alertmanager corresponds to the JSON schema field "alertmanager".
	Alertmanager *SpecDistributionModulesMonitoringAlertManager `json:"alertmanager,omitempty" yaml:"alertmanager,omitempty" mapstructure:"alertmanager,omitempty"`

	// BlackboxExporter corresponds to the JSON schema field "blackboxExporter".
	BlackboxExporter *SpecDistributionModulesMonitoringBlackboxExporter `json:"blackboxExporter,omitempty" yaml:"blackboxExporter,omitempty" mapstructure:"blackboxExporter,omitempty"`

	// Grafana corresponds to the JSON schema field "grafana".
	Grafana *SpecDistributionModulesMonitoringGrafana `json:"grafana,omitempty" yaml:"grafana,omitempty" mapstructure:"grafana,omitempty"`

	// KubeStateMetrics corresponds to the JSON schema field "kubeStateMetrics".
	KubeStateMetrics *SpecDistributionModulesMonitoringKubeStateMetrics `json:"kubeStateMetrics,omitempty" yaml:"kubeStateMetrics,omitempty" mapstructure:"kubeStateMetrics,omitempty"`

	// Mimir corresponds to the JSON schema field "mimir".
	Mimir *SpecDistributionModulesMonitoringMimir `json:"mimir,omitempty" yaml:"mimir,omitempty" mapstructure:"mimir,omitempty"`

	// Minio corresponds to the JSON schema field "minio".
	Minio *SpecDistributionModulesMonitoringMinio `json:"minio,omitempty" yaml:"minio,omitempty" mapstructure:"minio,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Prometheus corresponds to the JSON schema field "prometheus".
	Prometheus *SpecDistributionModulesMonitoringPrometheus `json:"prometheus,omitempty" yaml:"prometheus,omitempty" mapstructure:"prometheus,omitempty"`

	// The type of the monitoring, must be ***none***, ***prometheus*** or ***mimir***
	Type SpecDistributionModulesMonitoringType `json:"type" yaml:"type" mapstructure:"type"`

	// X509Exporter corresponds to the JSON schema field "x509Exporter".
	X509Exporter *SpecDistributionModulesMonitoringX509Exporter `json:"x509Exporter,omitempty" yaml:"x509Exporter,omitempty" mapstructure:"x509Exporter,omitempty"`
}

type SpecDistributionModulesMonitoringAlertManager struct {
	// The webhook url to send deadman switch monitoring, for example to use with
	// healthchecks.io
	DeadManSwitchWebhookUrl *string `json:"deadManSwitchWebhookUrl,omitempty" yaml:"deadManSwitchWebhookUrl,omitempty" mapstructure:"deadManSwitchWebhookUrl,omitempty"`

	// If true, the default rules will be installed
	InstallDefaultRules *bool `json:"installDefaultRules,omitempty" yaml:"installDefaultRules,omitempty" mapstructure:"installDefaultRules,omitempty"`

	// The slack webhook url to send alerts
	SlackWebhookUrl *string `json:"slackWebhookUrl,omitempty" yaml:"slackWebhookUrl,omitempty" mapstructure:"slackWebhookUrl,omitempty"`
}

type SpecDistributionModulesMonitoringBlackboxExporter struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesMonitoringGrafana struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesMonitoringKubeStateMetrics struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesMonitoringMimir struct {
	// The backend for the mimir pods, must be ***minio*** or ***externalEndpoint***
	Backend *SpecDistributionModulesMonitoringMimirBackend `json:"backend,omitempty" yaml:"backend,omitempty" mapstructure:"backend,omitempty"`

	// ExternalEndpoint corresponds to the JSON schema field "externalEndpoint".
	ExternalEndpoint *SpecDistributionModulesMonitoringMimirExternalEndpoint `json:"externalEndpoint,omitempty" yaml:"externalEndpoint,omitempty" mapstructure:"externalEndpoint,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The retention time for the mimir pods
	RetentionTime *string `json:"retentionTime,omitempty" yaml:"retentionTime,omitempty" mapstructure:"retentionTime,omitempty"`
}

type SpecDistributionModulesMonitoringMimirBackend string

const (
	SpecDistributionModulesMonitoringMimirBackendExternalEndpoint SpecDistributionModulesMonitoringMimirBackend = "externalEndpoint"
	SpecDistributionModulesMonitoringMimirBackendMinio            SpecDistributionModulesMonitoringMimirBackend = "minio"
)

type SpecDistributionModulesMonitoringMimirExternalEndpoint struct {
	// The access key id of the external mimir backend
	AccessKeyId *string `json:"accessKeyId,omitempty" yaml:"accessKeyId,omitempty" mapstructure:"accessKeyId,omitempty"`

	// The bucket name of the external mimir backend
	BucketName *string `json:"bucketName,omitempty" yaml:"bucketName,omitempty" mapstructure:"bucketName,omitempty"`

	// The endpoint of the external mimir backend
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty" mapstructure:"endpoint,omitempty"`

	// If true, the external mimir backend will not use tls
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// The secret access key of the external mimir backend
	SecretAccessKey *string `json:"secretAccessKey,omitempty" yaml:"secretAccessKey,omitempty" mapstructure:"secretAccessKey,omitempty"`
}

type SpecDistributionModulesMonitoringMinio struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// RootUser corresponds to the JSON schema field "rootUser".
	RootUser *SpecDistributionModulesMonitoringMinioRootUser `json:"rootUser,omitempty" yaml:"rootUser,omitempty" mapstructure:"rootUser,omitempty"`

	// The storage size for the minio pods
	StorageSize *string `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesMonitoringMinioRootUser struct {
	// The password for the minio root user
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// The username for the minio root user
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

type SpecDistributionModulesMonitoringPrometheus struct {
	// Resources corresponds to the JSON schema field "resources".
	Resources *TypesKubeResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// The retention size for the prometheus pods
	RetentionSize *string `json:"retentionSize,omitempty" yaml:"retentionSize,omitempty" mapstructure:"retentionSize,omitempty"`

	// The retention time for the prometheus pods
	RetentionTime *string `json:"retentionTime,omitempty" yaml:"retentionTime,omitempty" mapstructure:"retentionTime,omitempty"`

	// The storage size for the prometheus pods
	StorageSize *string `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesMonitoringType string

const (
	SpecDistributionModulesMonitoringTypeMimir      SpecDistributionModulesMonitoringType = "mimir"
	SpecDistributionModulesMonitoringTypeNone       SpecDistributionModulesMonitoringType = "none"
	SpecDistributionModulesMonitoringTypePrometheus SpecDistributionModulesMonitoringType = "prometheus"
)

type SpecDistributionModulesMonitoringX509Exporter struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesNetworking struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// TigeraOperator corresponds to the JSON schema field "tigeraOperator".
	TigeraOperator *SpecDistributionModulesNetworkingTigeraOperator `json:"tigeraOperator,omitempty" yaml:"tigeraOperator,omitempty" mapstructure:"tigeraOperator,omitempty"`
}

type SpecDistributionModulesNetworkingTigeraOperator struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesPolicy struct {
	// Gatekeeper corresponds to the JSON schema field "gatekeeper".
	Gatekeeper *SpecDistributionModulesPolicyGatekeeper `json:"gatekeeper,omitempty" yaml:"gatekeeper,omitempty" mapstructure:"gatekeeper,omitempty"`

	// Kyverno corresponds to the JSON schema field "kyverno".
	Kyverno *SpecDistributionModulesPolicyKyverno `json:"kyverno,omitempty" yaml:"kyverno,omitempty" mapstructure:"kyverno,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The type of security to use, either ***none***, ***gatekeeper*** or
	// ***kyverno***
	Type SpecDistributionModulesPolicyType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesPolicyGatekeeper struct {
	// This parameter adds namespaces to Gatekeeper's exemption list, so it will not
	// enforce the constraints on them.
	AdditionalExcludedNamespaces []string `json:"additionalExcludedNamespaces,omitempty" yaml:"additionalExcludedNamespaces,omitempty" mapstructure:"additionalExcludedNamespaces,omitempty"`

	// The enforcement action to use for the gatekeeper module
	EnforcementAction SpecDistributionModulesPolicyGatekeeperEnforcementAction `json:"enforcementAction" yaml:"enforcementAction" mapstructure:"enforcementAction"`

	// If true, the default policies will be installed
	InstallDefaultPolicies bool `json:"installDefaultPolicies" yaml:"installDefaultPolicies" mapstructure:"installDefaultPolicies"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`
}

type SpecDistributionModulesPolicyGatekeeperEnforcementAction string

const (
	SpecDistributionModulesPolicyGatekeeperEnforcementActionDeny   SpecDistributionModulesPolicyGatekeeperEnforcementAction = "deny"
	SpecDistributionModulesPolicyGatekeeperEnforcementActionDryrun SpecDistributionModulesPolicyGatekeeperEnforcementAction = "dryrun"
	SpecDistributionModulesPolicyGatekeeperEnforcementActionWarn   SpecDistributionModulesPolicyGatekeeperEnforcementAction = "warn"
)

type SpecDistributionModulesPolicyKyverno struct {
	// This parameter adds namespaces to Kyverno's exemption list, so it will not
	// enforce the constraints on them.
	AdditionalExcludedNamespaces []string `json:"additionalExcludedNamespaces,omitempty" yaml:"additionalExcludedNamespaces,omitempty" mapstructure:"additionalExcludedNamespaces,omitempty"`

	// If true, the default policies will be installed
	InstallDefaultPolicies bool `json:"installDefaultPolicies" yaml:"installDefaultPolicies" mapstructure:"installDefaultPolicies"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The validation failure action to use for the kyverno module
	ValidationFailureAction SpecDistributionModulesPolicyKyvernoValidationFailureAction `json:"validationFailureAction" yaml:"validationFailureAction" mapstructure:"validationFailureAction"`
}

type SpecDistributionModulesPolicyKyvernoValidationFailureAction string

const (
	SpecDistributionModulesPolicyKyvernoValidationFailureActionAudit   SpecDistributionModulesPolicyKyvernoValidationFailureAction = "audit"
	SpecDistributionModulesPolicyKyvernoValidationFailureActionEnforce SpecDistributionModulesPolicyKyvernoValidationFailureAction = "enforce"
)

type SpecDistributionModulesPolicyType string

const (
	SpecDistributionModulesPolicyTypeGatekeeper SpecDistributionModulesPolicyType = "gatekeeper"
	SpecDistributionModulesPolicyTypeKyverno    SpecDistributionModulesPolicyType = "kyverno"
	SpecDistributionModulesPolicyTypeNone       SpecDistributionModulesPolicyType = "none"
)

type SpecDistributionModulesTracing struct {
	// Minio corresponds to the JSON schema field "minio".
	Minio *SpecDistributionModulesTracingMinio `json:"minio,omitempty" yaml:"minio,omitempty" mapstructure:"minio,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// Tempo corresponds to the JSON schema field "tempo".
	Tempo *SpecDistributionModulesTracingTempo `json:"tempo,omitempty" yaml:"tempo,omitempty" mapstructure:"tempo,omitempty"`

	// The type of tracing to use, either ***none*** or ***tempo***
	Type SpecDistributionModulesTracingType `json:"type" yaml:"type" mapstructure:"type"`
}

type SpecDistributionModulesTracingMinio struct {
	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// RootUser corresponds to the JSON schema field "rootUser".
	RootUser *SpecDistributionModulesTracingMinioRootUser `json:"rootUser,omitempty" yaml:"rootUser,omitempty" mapstructure:"rootUser,omitempty"`

	// The storage size for the minio pods
	StorageSize *string `json:"storageSize,omitempty" yaml:"storageSize,omitempty" mapstructure:"storageSize,omitempty"`
}

type SpecDistributionModulesTracingMinioRootUser struct {
	// The password for the minio root user
	Password *string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// The username for the minio root user
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

type SpecDistributionModulesTracingTempo struct {
	// The backend for the tempo pods, must be ***minio*** or ***externalEndpoint***
	Backend *SpecDistributionModulesTracingTempoBackend `json:"backend,omitempty" yaml:"backend,omitempty" mapstructure:"backend,omitempty"`

	// ExternalEndpoint corresponds to the JSON schema field "externalEndpoint".
	ExternalEndpoint *SpecDistributionModulesTracingTempoExternalEndpoint `json:"externalEndpoint,omitempty" yaml:"externalEndpoint,omitempty" mapstructure:"externalEndpoint,omitempty"`

	// Overrides corresponds to the JSON schema field "overrides".
	Overrides *TypesFuryModuleComponentOverrides `json:"overrides,omitempty" yaml:"overrides,omitempty" mapstructure:"overrides,omitempty"`

	// The retention time for the tempo pods
	RetentionTime *string `json:"retentionTime,omitempty" yaml:"retentionTime,omitempty" mapstructure:"retentionTime,omitempty"`
}

type SpecDistributionModulesTracingTempoBackend string

const (
	SpecDistributionModulesTracingTempoBackendExternalEndpoint SpecDistributionModulesTracingTempoBackend = "externalEndpoint"
	SpecDistributionModulesTracingTempoBackendMinio            SpecDistributionModulesTracingTempoBackend = "minio"
)

type SpecDistributionModulesTracingTempoExternalEndpoint struct {
	// The access key id of the external tempo backend
	AccessKeyId *string `json:"accessKeyId,omitempty" yaml:"accessKeyId,omitempty" mapstructure:"accessKeyId,omitempty"`

	// The bucket name of the external tempo backend
	BucketName *string `json:"bucketName,omitempty" yaml:"bucketName,omitempty" mapstructure:"bucketName,omitempty"`

	// The endpoint of the external tempo backend
	Endpoint *string `json:"endpoint,omitempty" yaml:"endpoint,omitempty" mapstructure:"endpoint,omitempty"`

	// If true, the external tempo backend will not use tls
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// The secret access key of the external tempo backend
	SecretAccessKey *string `json:"secretAccessKey,omitempty" yaml:"secretAccessKey,omitempty" mapstructure:"secretAccessKey,omitempty"`
}

type SpecDistributionModulesTracingType string

const (
	SpecDistributionModulesTracingTypeNone  SpecDistributionModulesTracingType = "none"
	SpecDistributionModulesTracingTypeTempo SpecDistributionModulesTracingType = "tempo"
)

type SpecInfrastructure struct {
	// This key defines the VPC that will be created in AWS
	Vpc *SpecInfrastructureVpc `json:"vpc,omitempty" yaml:"vpc,omitempty" mapstructure:"vpc,omitempty"`

	// This section defines the creation of VPN bastions
	Vpn *SpecInfrastructureVpn `json:"vpn,omitempty" yaml:"vpn,omitempty" mapstructure:"vpn,omitempty"`
}

type SpecInfrastructureVpc struct {
	// Network corresponds to the JSON schema field "network".
	Network SpecInfrastructureVpcNetwork `json:"network" yaml:"network" mapstructure:"network"`
}

type SpecInfrastructureVpcNetwork struct {
	// This is the CIDR of the VPC that will be created
	Cidr TypesCidr `json:"cidr" yaml:"cidr" mapstructure:"cidr"`

	// SubnetsCidrs corresponds to the JSON schema field "subnetsCidrs".
	SubnetsCidrs SpecInfrastructureVpcNetworkSubnetsCidrs `json:"subnetsCidrs" yaml:"subnetsCidrs" mapstructure:"subnetsCidrs"`
}

type SpecInfrastructureVpcNetworkSubnetsCidrs struct {
	// These are the CIRDs for the private subnets, where the nodes, the pods, and the
	// private load balancers will be created
	Private []TypesCidr `json:"private" yaml:"private" mapstructure:"private"`

	// These are the CIDRs for the public subnets, where the public load balancers and
	// the VPN servers will be created
	Public []TypesCidr `json:"public" yaml:"public" mapstructure:"public"`
}

type SpecInfrastructureVpn struct {
	// This value defines the prefix that will be used to create the bucket name where
	// the VPN servers will store the states
	BucketNamePrefix *TypesAwsS3BucketNamePrefix `json:"bucketNamePrefix,omitempty" yaml:"bucketNamePrefix,omitempty" mapstructure:"bucketNamePrefix,omitempty"`

	// The dhParamsBits size used for the creation of the .pem file that will be used
	// in the dh openvpn server.conf file
	DhParamsBits *int `json:"dhParamsBits,omitempty" yaml:"dhParamsBits,omitempty" mapstructure:"dhParamsBits,omitempty"`

	// The size of the disk in GB
	DiskSize *int `json:"diskSize,omitempty" yaml:"diskSize,omitempty" mapstructure:"diskSize,omitempty"`

	// Overrides the default IAM user name for the VPN
	IamUserNameOverride *TypesAwsIamRoleName `json:"iamUserNameOverride,omitempty" yaml:"iamUserNameOverride,omitempty" mapstructure:"iamUserNameOverride,omitempty"`

	// The size of the AWS EC2 instance
	InstanceType *string `json:"instanceType,omitempty" yaml:"instanceType,omitempty" mapstructure:"instanceType,omitempty"`

	// The number of instances to create, 0 to skip the creation
	Instances *int `json:"instances,omitempty" yaml:"instances,omitempty" mapstructure:"instances,omitempty"`

	// The username of the account to create in the bastion's operating system
	OperatorName *string `json:"operatorName,omitempty" yaml:"operatorName,omitempty" mapstructure:"operatorName,omitempty"`

	// The port used by the OpenVPN server
	Port *TypesTcpPort `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`

	// Ssh corresponds to the JSON schema field "ssh".
	Ssh SpecInfrastructureVpnSsh `json:"ssh" yaml:"ssh" mapstructure:"ssh"`

	// The VPC ID where the VPN servers will be created, required only if
	// .spec.infrastructure.vpc is omitted
	VpcId *TypesAwsVpcId `json:"vpcId,omitempty" yaml:"vpcId,omitempty" mapstructure:"vpcId,omitempty"`

	// The CIDR that will be used to assign IP addresses to the VPN clients when
	// connected
	VpnClientsSubnetCidr TypesCidr `json:"vpnClientsSubnetCidr" yaml:"vpnClientsSubnetCidr" mapstructure:"vpnClientsSubnetCidr"`
}

type SpecInfrastructureVpnSsh struct {
	// The CIDR enabled in the security group that can access the bastions in SSH
	AllowedFromCidrs []TypesCidr `json:"allowedFromCidrs" yaml:"allowedFromCidrs" mapstructure:"allowedFromCidrs"`

	// The github user name list that will be used to get the ssh public key that will
	// be added as authorized key to the operatorName user
	GithubUsersName []string `json:"githubUsersName" yaml:"githubUsersName" mapstructure:"githubUsersName"`

	// This value defines the public keys that will be added to the bastion's
	// operating system NOTES: Not yet implemented
	PublicKeys []interface{} `json:"publicKeys,omitempty" yaml:"publicKeys,omitempty" mapstructure:"publicKeys,omitempty"`
}

type SpecKubernetes struct {
	// ApiServer corresponds to the JSON schema field "apiServer".
	ApiServer SpecKubernetesAPIServer `json:"apiServer" yaml:"apiServer" mapstructure:"apiServer"`

	// AwsAuth corresponds to the JSON schema field "awsAuth".
	AwsAuth *SpecKubernetesAwsAuth `json:"awsAuth,omitempty" yaml:"awsAuth,omitempty" mapstructure:"awsAuth,omitempty"`

	// Overrides the default IAM role name prefix for the EKS cluster
	ClusterIAMRoleNamePrefixOverride *TypesAwsIamRoleNamePrefix `json:"clusterIAMRoleNamePrefixOverride,omitempty" yaml:"clusterIAMRoleNamePrefixOverride,omitempty" mapstructure:"clusterIAMRoleNamePrefixOverride,omitempty"`

	// Optional Kubernetes Cluster log retention in days. Defaults to 90 days.
	LogRetentionDays *int `json:"logRetentionDays,omitempty" yaml:"logRetentionDays,omitempty" mapstructure:"logRetentionDays,omitempty"`

	// Optional list of Kubernetes Cluster log types to enable. Defaults to all types.
	LogsTypes []SpecKubernetesLogsTypesElem `json:"logsTypes,omitempty" yaml:"logsTypes,omitempty" mapstructure:"logsTypes,omitempty"`

	// This key contains the ssh public key that can connect to the nodes via SSH
	// using the ec2-user user
	NodeAllowedSshPublicKey interface{} `json:"nodeAllowedSshPublicKey" yaml:"nodeAllowedSshPublicKey" mapstructure:"nodeAllowedSshPublicKey"`

	// NodePools corresponds to the JSON schema field "nodePools".
	NodePools []SpecKubernetesNodePool `json:"nodePools" yaml:"nodePools" mapstructure:"nodePools"`

	// Either `launch_configurations`, `launch_templates` or `both`. For new clusters
	// use `launch_templates`, for existing cluster you'll need to migrate from
	// `launch_configurations` to `launch_templates` using `both` as interim.
	NodePoolsLaunchKind SpecKubernetesNodePoolsLaunchKind `json:"nodePoolsLaunchKind" yaml:"nodePoolsLaunchKind" mapstructure:"nodePoolsLaunchKind"`

	// This value defines the CIDR that will be used to assign IP addresses to the
	// services
	ServiceIpV4Cidr *TypesCidr `json:"serviceIpV4Cidr,omitempty" yaml:"serviceIpV4Cidr,omitempty" mapstructure:"serviceIpV4Cidr,omitempty"`

	// This value defines the subnet IDs where the EKS cluster will be created,
	// required only if .spec.infrastructure.vpc is omitted
	SubnetIds []TypesAwsSubnetId `json:"subnetIds,omitempty" yaml:"subnetIds,omitempty" mapstructure:"subnetIds,omitempty"`

	// This value defines the VPC ID where the EKS cluster will be created, required
	// only if .spec.infrastructure.vpc is omitted
	VpcId *TypesAwsVpcId `json:"vpcId,omitempty" yaml:"vpcId,omitempty" mapstructure:"vpcId,omitempty"`

	// Overrides the default IAM role name prefix for the EKS workers
	WorkersIAMRoleNamePrefixOverride *TypesAwsIamRoleNamePrefix `json:"workersIAMRoleNamePrefixOverride,omitempty" yaml:"workersIAMRoleNamePrefixOverride,omitempty" mapstructure:"workersIAMRoleNamePrefixOverride,omitempty"`
}

type SpecKubernetesAPIServer struct {
	// This value defines if the API server will be accessible only from the private
	// subnets
	PrivateAccess bool `json:"privateAccess" yaml:"privateAccess" mapstructure:"privateAccess"`

	// This value defines the CIDRs that will be allowed to access the API server from
	// the private subnets
	PrivateAccessCidrs []TypesCidr `json:"privateAccessCidrs,omitempty" yaml:"privateAccessCidrs,omitempty" mapstructure:"privateAccessCidrs,omitempty"`

	// This value defines if the API server will be accessible from the public subnets
	PublicAccess bool `json:"publicAccess" yaml:"publicAccess" mapstructure:"publicAccess"`

	// This value defines the CIDRs that will be allowed to access the API server from
	// the public subnets
	PublicAccessCidrs []TypesCidr `json:"publicAccessCidrs,omitempty" yaml:"publicAccessCidrs,omitempty" mapstructure:"publicAccessCidrs,omitempty"`
}

type SpecKubernetesAwsAuth struct {
	// This optional array defines additional AWS accounts that will be added to the
	// aws-auth configmap
	AdditionalAccounts []string `json:"additionalAccounts,omitempty" yaml:"additionalAccounts,omitempty" mapstructure:"additionalAccounts,omitempty"`

	// This optional array defines additional IAM roles that will be added to the
	// aws-auth configmap
	Roles []SpecKubernetesAwsAuthRole `json:"roles,omitempty" yaml:"roles,omitempty" mapstructure:"roles,omitempty"`

	// This optional array defines additional IAM users that will be added to the
	// aws-auth configmap
	Users []SpecKubernetesAwsAuthUser `json:"users,omitempty" yaml:"users,omitempty" mapstructure:"users,omitempty"`
}

type SpecKubernetesAwsAuthRole struct {
	// Groups corresponds to the JSON schema field "groups".
	Groups []string `json:"groups" yaml:"groups" mapstructure:"groups"`

	// Rolearn corresponds to the JSON schema field "rolearn".
	Rolearn TypesAwsArn `json:"rolearn" yaml:"rolearn" mapstructure:"rolearn"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username" mapstructure:"username"`
}

type SpecKubernetesAwsAuthUser struct {
	// Groups corresponds to the JSON schema field "groups".
	Groups []string `json:"groups" yaml:"groups" mapstructure:"groups"`

	// Userarn corresponds to the JSON schema field "userarn".
	Userarn TypesAwsArn `json:"userarn" yaml:"userarn" mapstructure:"userarn"`

	// Username corresponds to the JSON schema field "username".
	Username string `json:"username" yaml:"username" mapstructure:"username"`
}

type SpecKubernetesLogsTypesElem string

const (
	SpecKubernetesLogsTypesElemApi           SpecKubernetesLogsTypesElem = "api"
	SpecKubernetesLogsTypesElemAudit         SpecKubernetesLogsTypesElem = "audit"
	SpecKubernetesLogsTypesElemAuthenticator SpecKubernetesLogsTypesElem = "authenticator"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpnSsh) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["allowedFromCidrs"]; !ok || v == nil {
		return fmt.Errorf("field allowedFromCidrs in SpecInfrastructureVpnSsh: required")
	}
	if v, ok := raw["githubUsersName"]; !ok || v == nil {
		return fmt.Errorf("field githubUsersName in SpecInfrastructureVpnSsh: required")
	}
	type Plain SpecInfrastructureVpnSsh
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.GithubUsersName != nil && len(plain.GithubUsersName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "githubUsersName", 1)
	}
	*j = SpecInfrastructureVpnSsh(plain)
	return nil
}

var enumValues_SpecDistributionModulesIngressNginxType = []interface{}{
	"none",
	"single",
	"dual",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginx) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesIngressNginx: required")
	}
	type Plain SpecDistributionModulesIngressNginx
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginx(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionModulesIngressNginxTLS: required")
	}
	type Plain SpecDistributionModulesIngressNginxTLS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginxTLS(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLSSecret) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ca"]; !ok || v == nil {
		return fmt.Errorf("field ca in SpecDistributionModulesIngressNginxTLSSecret: required")
	}
	if v, ok := raw["cert"]; !ok || v == nil {
		return fmt.Errorf("field cert in SpecDistributionModulesIngressNginxTLSSecret: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in SpecDistributionModulesIngressNginxTLSSecret: required")
	}
	type Plain SpecDistributionModulesIngressNginxTLSSecret
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressNginxTLSSecret(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxTLSProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxTLSProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxTLSProvider, v)
	}
	*j = SpecDistributionModulesIngressNginxTLSProvider(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["baseDomain"]; !ok || v == nil {
		return fmt.Errorf("field baseDomain in SpecDistributionModulesIngress: required")
	}
	if v, ok := raw["dns"]; !ok || v == nil {
		return fmt.Errorf("field dns in SpecDistributionModulesIngress: required")
	}
	if v, ok := raw["nginx"]; !ok || v == nil {
		return fmt.Errorf("field nginx in SpecDistributionModulesIngress: required")
	}
	type Plain SpecDistributionModulesIngress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngress(plain)
	return nil
}

var enumValues_SpecDistributionModulesIngressNginxTLSProvider = []interface{}{
	"certManager",
	"secret",
	"none",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNS) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["private"]; !ok || v == nil {
		return fmt.Errorf("field private in SpecDistributionModulesIngressDNS: required")
	}
	if v, ok := raw["public"]; !ok || v == nil {
		return fmt.Errorf("field public in SpecDistributionModulesIngressDNS: required")
	}
	type Plain SpecDistributionModulesIngressDNS
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNS(plain)
	return nil
}

var enumValues_SpecDistributionModulesLoggingLokiBackend = []interface{}{
	"minio",
	"externalEndpoint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingLokiBackend) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesLoggingLokiBackend {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesLoggingLokiBackend, v)
	}
	*j = SpecDistributionModulesLoggingLokiBackend(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNSPublic) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["create"]; !ok || v == nil {
		return fmt.Errorf("field create in SpecDistributionModulesIngressDNSPublic: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressDNSPublic: required")
	}
	type Plain SpecDistributionModulesIngressDNSPublic
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNSPublic(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressDNSPrivate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["create"]; !ok || v == nil {
		return fmt.Errorf("field create in SpecDistributionModulesIngressDNSPrivate: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressDNSPrivate: required")
	}
	type Plain SpecDistributionModulesIngressDNSPrivate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressDNSPrivate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManager) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["clusterIssuer"]; !ok || v == nil {
		return fmt.Errorf("field clusterIssuer in SpecDistributionModulesIngressCertManager: required")
	}
	type Plain SpecDistributionModulesIngressCertManager
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressCertManager(plain)
	return nil
}

type TypesKubeResourcesLimits struct {
	// The cpu limit for the opensearch pods
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty" mapstructure:"cpu,omitempty"`

	// The memory limit for the opensearch pods
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty" mapstructure:"memory,omitempty"`
}

type TypesKubeResourcesRequests struct {
	// The cpu request for the prometheus pods
	Cpu *string `json:"cpu,omitempty" yaml:"cpu,omitempty" mapstructure:"cpu,omitempty"`

	// The memory request for the opensearch pods
	Memory *string `json:"memory,omitempty" yaml:"memory,omitempty" mapstructure:"memory,omitempty"`
}

type TypesKubeResources struct {
	// Limits corresponds to the JSON schema field "limits".
	Limits *TypesKubeResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *TypesKubeResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManagerClusterIssuer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email in SpecDistributionModulesIngressCertManagerClusterIssuer: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionModulesIngressCertManagerClusterIssuer: required")
	}
	type Plain SpecDistributionModulesIngressCertManagerClusterIssuer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesIngressCertManagerClusterIssuer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressCertManagerClusterIssuerType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType, v)
	}
	*j = SpecDistributionModulesIngressCertManagerClusterIssuerType(v)
	return nil
}

var enumValues_SpecDistributionModulesIngressCertManagerClusterIssuerType = []interface{}{
	"dns01",
	"http01",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDr) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesDr: required")
	}
	type Plain SpecDistributionModulesDr
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesDr(plain)
	return nil
}

var enumValues_SpecDistributionModulesLoggingOpensearchType = []interface{}{
	"single",
	"triple",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingOpensearchType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesLoggingOpensearchType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesLoggingOpensearchType, v)
	}
	*j = SpecDistributionModulesLoggingOpensearchType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrVelero) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eks"]; !ok || v == nil {
		return fmt.Errorf("field eks in SpecDistributionModulesDrVelero: required")
	}
	type Plain SpecDistributionModulesDrVelero
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesDrVelero(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrVeleroEks) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bucketName"]; !ok || v == nil {
		return fmt.Errorf("field bucketName in SpecDistributionModulesDrVeleroEks: required")
	}
	if v, ok := raw["region"]; !ok || v == nil {
		return fmt.Errorf("field region in SpecDistributionModulesDrVeleroEks: required")
	}
	type Plain SpecDistributionModulesDrVeleroEks
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesDrVeleroEks(plain)
	return nil
}

const TypesAwsRegionUsWest2 TypesAwsRegion = "us-west-2"

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingOpensearch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesLoggingOpensearch: required")
	}
	type Plain SpecDistributionModulesLoggingOpensearch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesLoggingOpensearch(plain)
	return nil
}

const (
	TypesAwsRegionUsWest1    TypesAwsRegion = "us-west-1"
	TypesAwsRegionUsGovWest1 TypesAwsRegion = "us-gov-west-1"
)

var enumValues_SpecDistributionModulesLoggingType = []interface{}{
	"none",
	"opensearch",
	"loki",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLoggingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesLoggingType, v)
	}
	*j = SpecDistributionModulesLoggingType(v)
	return nil
}

const (
	TypesAwsRegionUsGovEast1 TypesAwsRegion = "us-gov-east-1"
	TypesAwsRegionUsEast2    TypesAwsRegion = "us-east-2"
	TypesAwsRegionUsEast1    TypesAwsRegion = "us-east-1"
	TypesAwsRegionSaEast1    TypesAwsRegion = "sa-east-1"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesLogging) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesLogging: required")
	}
	type Plain SpecDistributionModulesLogging
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesLogging(plain)
	return nil
}

const (
	TypesAwsRegionMeSouth1   TypesAwsRegion = "me-south-1"
	TypesAwsRegionMeCentral1 TypesAwsRegion = "me-central-1"
	TypesAwsRegionEuWest3    TypesAwsRegion = "eu-west-3"
	TypesAwsRegionEuWest2    TypesAwsRegion = "eu-west-2"
	TypesAwsRegionEuWest1    TypesAwsRegion = "eu-west-1"
)

var enumValues_SpecDistributionModulesMonitoringMimirBackend = []interface{}{
	"minio",
	"externalEndpoint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesMonitoringMimirBackend) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesMonitoringMimirBackend {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesMonitoringMimirBackend, v)
	}
	*j = SpecDistributionModulesMonitoringMimirBackend(v)
	return nil
}

const (
	TypesAwsRegionEuSouth2     TypesAwsRegion = "eu-south-2"
	TypesAwsRegionEuSouth1     TypesAwsRegion = "eu-south-1"
	TypesAwsRegionEuNorth1     TypesAwsRegion = "eu-north-1"
	TypesAwsRegionEuCentral2   TypesAwsRegion = "eu-central-2"
	TypesAwsRegionEuCentral1   TypesAwsRegion = "eu-central-1"
	TypesAwsRegionCaCentral1   TypesAwsRegion = "ca-central-1"
	TypesAwsRegionApSoutheast4 TypesAwsRegion = "ap-southeast-4"
	TypesAwsRegionApSoutheast3 TypesAwsRegion = "ap-southeast-3"
)

var enumValues_SpecDistributionModulesMonitoringType = []interface{}{
	"none",
	"prometheus",
	"mimir",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesMonitoringType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesMonitoringType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesMonitoringType, v)
	}
	*j = SpecDistributionModulesMonitoringType(v)
	return nil
}

const (
	TypesAwsRegionApSoutheast2 TypesAwsRegion = "ap-southeast-2"
	TypesAwsRegionApSoutheast1 TypesAwsRegion = "ap-southeast-1"
	TypesAwsRegionApSouth2     TypesAwsRegion = "ap-south-2"
	TypesAwsRegionApSouth1     TypesAwsRegion = "ap-south-1"
	TypesAwsRegionApNortheast3 TypesAwsRegion = "ap-northeast-3"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesMonitoring) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesMonitoring: required")
	}
	type Plain SpecDistributionModulesMonitoring
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesMonitoring(plain)
	return nil
}

const (
	TypesAwsRegionApNortheast2 TypesAwsRegion = "ap-northeast-2"
	TypesAwsRegionApNortheast1 TypesAwsRegion = "ap-northeast-1"
	TypesAwsRegionApEast1      TypesAwsRegion = "ap-east-1"
)

var enumValues_SpecDistributionModulesPolicyGatekeeperEnforcementAction = []interface{}{
	"deny",
	"dryrun",
	"warn",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyGatekeeperEnforcementAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesPolicyGatekeeperEnforcementAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesPolicyGatekeeperEnforcementAction, v)
	}
	*j = SpecDistributionModulesPolicyGatekeeperEnforcementAction(v)
	return nil
}

const TypesAwsRegionAfSouth1 TypesAwsRegion = "af-south-1"

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesAwsRegion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesAwsRegion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesAwsRegion, v)
	}
	*j = TypesAwsRegion(v)
	return nil
}

var enumValues_TypesAwsRegion = []interface{}{
	"af-south-1",
	"ap-east-1",
	"ap-northeast-1",
	"ap-northeast-2",
	"ap-northeast-3",
	"ap-south-1",
	"ap-south-2",
	"ap-southeast-1",
	"ap-southeast-2",
	"ap-southeast-3",
	"ap-southeast-4",
	"ca-central-1",
	"eu-central-1",
	"eu-central-2",
	"eu-north-1",
	"eu-south-1",
	"eu-south-2",
	"eu-west-1",
	"eu-west-2",
	"eu-west-3",
	"me-central-1",
	"me-south-1",
	"sa-east-1",
	"us-east-1",
	"us-east-2",
	"us-gov-east-1",
	"us-gov-west-1",
	"us-west-1",
	"us-west-2",
}

type TypesAwsRegion string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyGatekeeper) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["enforcementAction"]; !ok || v == nil {
		return fmt.Errorf("field enforcementAction in SpecDistributionModulesPolicyGatekeeper: required")
	}
	if v, ok := raw["installDefaultPolicies"]; !ok || v == nil {
		return fmt.Errorf("field installDefaultPolicies in SpecDistributionModulesPolicyGatekeeper: required")
	}
	type Plain SpecDistributionModulesPolicyGatekeeper
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesPolicyGatekeeper(plain)
	return nil
}

type TypesAwsS3BucketName string

var enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction = []interface{}{
	"audit",
	"enforce",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyKyvernoValidationFailureAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesPolicyKyvernoValidationFailureAction, v)
	}
	*j = SpecDistributionModulesPolicyKyvernoValidationFailureAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesDrType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesDrType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesDrType, v)
	}
	*j = SpecDistributionModulesDrType(v)
	return nil
}

var enumValues_SpecDistributionModulesDrType = []interface{}{
	"none",
	"eks",
}

type TypesFuryModuleOverrides struct {
	// Ingresses corresponds to the JSON schema field "ingresses".
	Ingresses TypesFuryModuleOverridesIngresses `json:"ingresses,omitempty" yaml:"ingresses,omitempty" mapstructure:"ingresses,omitempty"`

	// The node selector to use to place the pods for the dr module
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// The tolerations that will be added to the pods for the monitoring module
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyKyverno) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["installDefaultPolicies"]; !ok || v == nil {
		return fmt.Errorf("field installDefaultPolicies in SpecDistributionModulesPolicyKyverno: required")
	}
	if v, ok := raw["validationFailureAction"]; !ok || v == nil {
		return fmt.Errorf("field validationFailureAction in SpecDistributionModulesPolicyKyverno: required")
	}
	type Plain SpecDistributionModulesPolicyKyverno
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesPolicyKyverno(plain)
	return nil
}

type TypesFuryModuleOverridesIngresses map[string]TypesFuryModuleOverridesIngress

var enumValues_SpecDistributionModulesPolicyType = []interface{}{
	"none",
	"gatekeeper",
	"kyverno",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesPolicyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesPolicyType, v)
	}
	*j = SpecDistributionModulesPolicyType(v)
	return nil
}

type TypesFuryModuleOverridesIngress struct {
	// If true, the ingress will not have authentication
	DisableAuth *bool `json:"disableAuth,omitempty" yaml:"disableAuth,omitempty" mapstructure:"disableAuth,omitempty"`

	// The host of the ingress
	Host *string `json:"host,omitempty" yaml:"host,omitempty" mapstructure:"host,omitempty"`

	// The ingress class of the ingress
	IngressClass *string `json:"ingressClass,omitempty" yaml:"ingressClass,omitempty" mapstructure:"ingressClass,omitempty"`
}

type TypesFuryModuleComponentOverridesWithIAMRoleName struct {
	// IamRoleName corresponds to the JSON schema field "iamRoleName".
	IamRoleName *TypesAwsIamRoleName `json:"iamRoleName,omitempty" yaml:"iamRoleName,omitempty" mapstructure:"iamRoleName,omitempty"`

	// The node selector to use to place the pods for the load balancer controller
	// module
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// The tolerations that will be added to the pods for the cluster autoscaler
	// module
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

type TypesAwsIamRoleName string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		return fmt.Errorf("field provider in SpecDistributionModulesAuth: required")
	}
	type Plain SpecDistributionModulesAuth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuth(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesPolicy: required")
	}
	type Plain SpecDistributionModulesPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesPolicy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesAuthProvider: required")
	}
	type Plain SpecDistributionModulesAuthProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthProvider(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProviderType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesAuthProviderType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesAuthProviderType, v)
	}
	*j = SpecDistributionModulesAuthProviderType(v)
	return nil
}

var enumValues_SpecDistributionModulesAuthProviderType = []interface{}{
	"none",
	"basicAuth",
	"sso",
}

var enumValues_SpecDistributionModulesTracingTempoBackend = []interface{}{
	"minio",
	"externalEndpoint",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesTracingTempoBackend) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesTracingTempoBackend {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesTracingTempoBackend, v)
	}
	*j = SpecDistributionModulesTracingTempoBackend(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthProviderBasicAuth) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password in SpecDistributionModulesAuthProviderBasicAuth: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecDistributionModulesAuthProviderBasicAuth: required")
	}
	type Plain SpecDistributionModulesAuthProviderBasicAuth
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthProviderBasicAuth(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthPomerium) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["policy"]; !ok || v == nil {
		return fmt.Errorf("field policy in SpecDistributionModulesAuthPomerium: required")
	}
	if v, ok := raw["secrets"]; !ok || v == nil {
		return fmt.Errorf("field secrets in SpecDistributionModulesAuthPomerium: required")
	}
	type Plain SpecDistributionModulesAuthPomerium
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthPomerium(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthPomeriumSecrets) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["COOKIE_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field COOKIE_SECRET in SpecDistributionModulesAuthPomeriumSecrets: required")
	}
	if v, ok := raw["IDP_CLIENT_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field IDP_CLIENT_SECRET in SpecDistributionModulesAuthPomeriumSecrets: required")
	}
	if v, ok := raw["SHARED_SECRET"]; !ok || v == nil {
		return fmt.Errorf("field SHARED_SECRET in SpecDistributionModulesAuthPomeriumSecrets: required")
	}
	type Plain SpecDistributionModulesAuthPomeriumSecrets
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthPomeriumSecrets(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthOverridesIngress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["host"]; !ok || v == nil {
		return fmt.Errorf("field host in SpecDistributionModulesAuthOverridesIngress: required")
	}
	if v, ok := raw["ingressClass"]; !ok || v == nil {
		return fmt.Errorf("field ingressClass in SpecDistributionModulesAuthOverridesIngress: required")
	}
	type Plain SpecDistributionModulesAuthOverridesIngress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthOverridesIngress(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesAuthDex) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["connectors"]; !ok || v == nil {
		return fmt.Errorf("field connectors in SpecDistributionModulesAuthDex: required")
	}
	type Plain SpecDistributionModulesAuthDex
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesAuthDex(plain)
	return nil
}

var enumValues_SpecDistributionModulesTracingType = []interface{}{
	"none",
	"tempo",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesTracingType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesTracingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesTracingType, v)
	}
	*j = SpecDistributionModulesTracingType(v)
	return nil
}

type TypesFuryModuleComponentOverrides struct {
	// The node selector to use to place the pods for the minio module
	NodeSelector TypesKubeNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// The tolerations that will be added to the pods for the cert-manager module
	Tolerations []TypesKubeToleration `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesSecretGeneratorResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionCustomPatchesSecretGeneratorResource: required")
	}
	type Plain SpecDistributionCustomPatchesSecretGeneratorResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCustomPatchesSecretGeneratorResource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesSecretGeneratorResourceBehavior) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior, v)
	}
	*j = SpecDistributionCustomPatchesSecretGeneratorResourceBehavior(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesTracing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionModulesTracing: required")
	}
	type Plain SpecDistributionModulesTracing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModulesTracing(plain)
	return nil
}

var enumValues_SpecDistributionCustomPatchesSecretGeneratorResourceBehavior = []interface{}{
	"create",
	"replace",
	"merge",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModules) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dr"]; !ok || v == nil {
		return fmt.Errorf("field dr in SpecDistributionModules: required")
	}
	if v, ok := raw["ingress"]; !ok || v == nil {
		return fmt.Errorf("field ingress in SpecDistributionModules: required")
	}
	if v, ok := raw["logging"]; !ok || v == nil {
		return fmt.Errorf("field logging in SpecDistributionModules: required")
	}
	if v, ok := raw["policy"]; !ok || v == nil {
		return fmt.Errorf("field policy in SpecDistributionModules: required")
	}
	type Plain SpecDistributionModules
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionModules(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesConfigMapGeneratorResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecDistributionCustomPatchesConfigMapGeneratorResource: required")
	}
	type Plain SpecDistributionCustomPatchesConfigMapGeneratorResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCustomPatchesConfigMapGeneratorResource(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["modules"]; !ok || v == nil {
		return fmt.Errorf("field modules in SpecDistribution: required")
	}
	type Plain SpecDistribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistribution(plain)
	return nil
}

type TypesCidr string

type TypesKubeLabels map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcNetworkSubnetsCidrs) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["private"]; !ok || v == nil {
		return fmt.Errorf("field private in SpecInfrastructureVpcNetworkSubnetsCidrs: required")
	}
	if v, ok := raw["public"]; !ok || v == nil {
		return fmt.Errorf("field public in SpecInfrastructureVpcNetworkSubnetsCidrs: required")
	}
	type Plain SpecInfrastructureVpcNetworkSubnetsCidrs
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcNetworkSubnetsCidrs(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior, v)
	}
	*j = SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpcNetwork) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cidr"]; !ok || v == nil {
		return fmt.Errorf("field cidr in SpecInfrastructureVpcNetwork: required")
	}
	if v, ok := raw["subnetsCidrs"]; !ok || v == nil {
		return fmt.Errorf("field subnetsCidrs in SpecInfrastructureVpcNetwork: required")
	}
	type Plain SpecInfrastructureVpcNetwork
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpcNetwork(plain)
	return nil
}

var enumValues_SpecDistributionCustomPatchesConfigMapGeneratorResourceBehavior = []interface{}{
	"create",
	"replace",
	"merge",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpc) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["network"]; !ok || v == nil {
		return fmt.Errorf("field network in SpecInfrastructureVpc: required")
	}
	type Plain SpecInfrastructureVpc
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpc(plain)
	return nil
}

type TypesAwsS3BucketNamePrefix string

type TypesTcpPort int

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeToleration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["effect"]; !ok || v == nil {
		return fmt.Errorf("field effect in TypesKubeToleration: required")
	}
	if v, ok := raw["key"]; !ok || v == nil {
		return fmt.Errorf("field key in TypesKubeToleration: required")
	}
	type Plain TypesKubeToleration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TypesKubeToleration(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionModulesIngressNginxType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecDistributionModulesIngressNginxType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecDistributionModulesIngressNginxType, v)
	}
	*j = SpecDistributionModulesIngressNginxType(v)
	return nil
}

type TypesAwsVpcId string

type TypesKubeToleration struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect TypesKubeTolerationEffect `json:"effect" yaml:"effect" mapstructure:"effect"`

	// The key of the toleration
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *TypesKubeTolerationOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// The value of the toleration
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecInfrastructureVpn) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ssh"]; !ok || v == nil {
		return fmt.Errorf("field ssh in SpecInfrastructureVpn: required")
	}
	if v, ok := raw["vpnClientsSubnetCidr"]; !ok || v == nil {
		return fmt.Errorf("field vpnClientsSubnetCidr in SpecInfrastructureVpn: required")
	}
	type Plain SpecInfrastructureVpn
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecInfrastructureVpn(plain)
	return nil
}

const (
	TypesKubeTolerationOperatorEqual  TypesKubeTolerationOperator = "Equal"
	TypesKubeTolerationOperatorExists TypesKubeTolerationOperator = "Exists"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAPIServer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["privateAccess"]; !ok || v == nil {
		return fmt.Errorf("field privateAccess in SpecKubernetesAPIServer: required")
	}
	if v, ok := raw["publicAccess"]; !ok || v == nil {
		return fmt.Errorf("field publicAccess in SpecKubernetesAPIServer: required")
	}
	type Plain SpecKubernetesAPIServer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAPIServer(plain)
	return nil
}

type TypesAwsArn string

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTolerationOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTolerationOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTolerationOperator, v)
	}
	*j = TypesKubeTolerationOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAwsAuthRole) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["groups"]; !ok || v == nil {
		return fmt.Errorf("field groups in SpecKubernetesAwsAuthRole: required")
	}
	if v, ok := raw["rolearn"]; !ok || v == nil {
		return fmt.Errorf("field rolearn in SpecKubernetesAwsAuthRole: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecKubernetesAwsAuthRole: required")
	}
	type Plain SpecKubernetesAwsAuthRole
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAwsAuthRole(plain)
	return nil
}

var enumValues_TypesKubeTolerationOperator = []interface{}{
	"Exists",
	"Equal",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesAwsAuthUser) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["groups"]; !ok || v == nil {
		return fmt.Errorf("field groups in SpecKubernetesAwsAuthUser: required")
	}
	if v, ok := raw["userarn"]; !ok || v == nil {
		return fmt.Errorf("field userarn in SpecKubernetesAwsAuthUser: required")
	}
	if v, ok := raw["username"]; !ok || v == nil {
		return fmt.Errorf("field username in SpecKubernetesAwsAuthUser: required")
	}
	type Plain SpecKubernetesAwsAuthUser
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesAwsAuthUser(plain)
	return nil
}

type TypesKubeTolerationOperator string

type TypesAwsIamRoleNamePrefix string

const TypesKubeTolerationEffectNoExecute TypesKubeTolerationEffect = "NoExecute"

var enumValues_SpecKubernetesLogsTypesElem = []interface{}{
	"api",
	"audit",
	"authenticator",
	"controllerManager",
	"scheduler",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesLogsTypesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesLogsTypesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesLogsTypesElem, v)
	}
	*j = SpecKubernetesLogsTypesElem(v)
	return nil
}

const (
	TypesKubeTolerationEffectPreferNoSchedule TypesKubeTolerationEffect = "PreferNoSchedule"
	TypesKubeTolerationEffectNoSchedule       TypesKubeTolerationEffect = "NoSchedule"
)

// UnmarshalJSON implements json.Unmarshaler.
func (j *TypesKubeTolerationEffect) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TypesKubeTolerationEffect {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TypesKubeTolerationEffect, v)
	}
	*j = TypesKubeTolerationEffect(v)
	return nil
}

const (
	SpecKubernetesLogsTypesElemControllerManager SpecKubernetesLogsTypesElem = "controllerManager"
	SpecKubernetesLogsTypesElemScheduler         SpecKubernetesLogsTypesElem = "scheduler"
)

type SpecKubernetesNodePoolAdditionalFirewallRulePorts struct {
	// From corresponds to the JSON schema field "from".
	From TypesTcpPort `json:"from" yaml:"from" mapstructure:"from"`

	// To corresponds to the JSON schema field "to".
	To TypesTcpPort `json:"to" yaml:"to" mapstructure:"to"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRulePorts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["from"]; !ok || v == nil {
		return fmt.Errorf("field from in SpecKubernetesNodePoolAdditionalFirewallRulePorts: required")
	}
	if v, ok := raw["to"]; !ok || v == nil {
		return fmt.Errorf("field to in SpecKubernetesNodePoolAdditionalFirewallRulePorts: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRulePorts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRulePorts(plain)
	return nil
}

type TypesAwsIpProtocol string

type TypesAwsTags map[string]string

type SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType string

var enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType = []interface{}{
	"ingress",
	"egress",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType, v)
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType(v)
	return nil
}

const (
	SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockTypeIngress SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType = "ingress"
	SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockTypeEgress  SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType = "egress"
)

type SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock struct {
	// CidrBlocks corresponds to the JSON schema field "cidrBlocks".
	CidrBlocks []TypesCidr `json:"cidrBlocks" yaml:"cidrBlocks" mapstructure:"cidrBlocks"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Ports corresponds to the JSON schema field "ports".
	Ports SpecKubernetesNodePoolAdditionalFirewallRulePorts `json:"ports" yaml:"ports" mapstructure:"ports"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol TypesAwsIpProtocol `json:"protocol" yaml:"protocol" mapstructure:"protocol"`

	// Tags corresponds to the JSON schema field "tags".
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlockType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cidrBlocks"]; !ok || v == nil {
		return fmt.Errorf("field cidrBlocks in SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock: required")
	}
	if v, ok := raw["ports"]; !ok || v == nil {
		return fmt.Errorf("field ports in SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol in SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.CidrBlocks != nil && len(plain.CidrBlocks) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cidrBlocks", 1)
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock(plain)
	return nil
}

type SpecKubernetesNodePoolAdditionalFirewallRuleSelfType string

var enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSelfType = []interface{}{
	"ingress",
	"egress",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleSelfType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSelfType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSelfType, v)
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleSelfType(v)
	return nil
}

const (
	SpecKubernetesNodePoolAdditionalFirewallRuleSelfTypeIngress SpecKubernetesNodePoolAdditionalFirewallRuleSelfType = "ingress"
	SpecKubernetesNodePoolAdditionalFirewallRuleSelfTypeEgress  SpecKubernetesNodePoolAdditionalFirewallRuleSelfType = "egress"
)

type SpecKubernetesNodePoolAdditionalFirewallRuleSelf struct {
	// The name of the FW rule
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Ports corresponds to the JSON schema field "ports".
	Ports SpecKubernetesNodePoolAdditionalFirewallRulePorts `json:"ports" yaml:"ports" mapstructure:"ports"`

	// The protocol of the FW rule
	Protocol TypesAwsIpProtocol `json:"protocol" yaml:"protocol" mapstructure:"protocol"`

	// If true, the source will be the security group itself
	Self bool `json:"self" yaml:"self" mapstructure:"self"`

	// The tags of the FW rule
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The type of the FW rule can be ingress or egress
	Type SpecKubernetesNodePoolAdditionalFirewallRuleSelfType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleSelf) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePoolAdditionalFirewallRuleSelf: required")
	}
	if v, ok := raw["ports"]; !ok || v == nil {
		return fmt.Errorf("field ports in SpecKubernetesNodePoolAdditionalFirewallRuleSelf: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol in SpecKubernetesNodePoolAdditionalFirewallRuleSelf: required")
	}
	if v, ok := raw["self"]; !ok || v == nil {
		return fmt.Errorf("field self in SpecKubernetesNodePoolAdditionalFirewallRuleSelf: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolAdditionalFirewallRuleSelf: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRuleSelf
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleSelf(plain)
	return nil
}

type SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType string

var enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType = []interface{}{
	"ingress",
	"egress",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType, v)
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType(v)
	return nil
}

const (
	SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdTypeIngress SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType = "ingress"
	SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdTypeEgress  SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType = "egress"
)

type SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId struct {
	// The name of the FW rule
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Ports corresponds to the JSON schema field "ports".
	Ports SpecKubernetesNodePoolAdditionalFirewallRulePorts `json:"ports" yaml:"ports" mapstructure:"ports"`

	// The protocol of the FW rule
	Protocol TypesAwsIpProtocol `json:"protocol" yaml:"protocol" mapstructure:"protocol"`

	// The source security group ID
	SourceSecurityGroupId string `json:"sourceSecurityGroupId" yaml:"sourceSecurityGroupId" mapstructure:"sourceSecurityGroupId"`

	// The tags of the FW rule
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The type of the FW rule can be ingress or egress
	Type SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupIdType `json:"type" yaml:"type" mapstructure:"type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId: required")
	}
	if v, ok := raw["ports"]; !ok || v == nil {
		return fmt.Errorf("field ports in SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId: required")
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		return fmt.Errorf("field protocol in SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId: required")
	}
	if v, ok := raw["sourceSecurityGroupId"]; !ok || v == nil {
		return fmt.Errorf("field sourceSecurityGroupId in SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId: required")
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId(plain)
	return nil
}

type SpecKubernetesNodePoolAdditionalFirewallRules struct {
	// The CIDR blocks for the FW rule. At the moment the first item of the list will
	// be used, others will be ignored.
	CidrBlocks []SpecKubernetesNodePoolAdditionalFirewallRuleCidrBlock `json:"cidrBlocks,omitempty" yaml:"cidrBlocks,omitempty" mapstructure:"cidrBlocks,omitempty"`

	// Self corresponds to the JSON schema field "self".
	Self []SpecKubernetesNodePoolAdditionalFirewallRuleSelf `json:"self,omitempty" yaml:"self,omitempty" mapstructure:"self,omitempty"`

	// SourceSecurityGroupId corresponds to the JSON schema field
	// "sourceSecurityGroupId".
	SourceSecurityGroupId []SpecKubernetesNodePoolAdditionalFirewallRuleSourceSecurityGroupId `json:"sourceSecurityGroupId,omitempty" yaml:"sourceSecurityGroupId,omitempty" mapstructure:"sourceSecurityGroupId,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAdditionalFirewallRules) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SpecKubernetesNodePoolAdditionalFirewallRules
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.CidrBlocks != nil && len(plain.CidrBlocks) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "cidrBlocks", 1)
	}
	if plain.Self != nil && len(plain.Self) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "self", 1)
	}
	if plain.SourceSecurityGroupId != nil && len(plain.SourceSecurityGroupId) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "sourceSecurityGroupId", 1)
	}
	*j = SpecKubernetesNodePoolAdditionalFirewallRules(plain)
	return nil
}

type SpecKubernetesNodePoolAmi struct {
	// The AMI ID to use for the nodes
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// The owner of the AMI
	Owner string `json:"owner" yaml:"owner" mapstructure:"owner"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolAmi) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in SpecKubernetesNodePoolAmi: required")
	}
	if v, ok := raw["owner"]; !ok || v == nil {
		return fmt.Errorf("field owner in SpecKubernetesNodePoolAmi: required")
	}
	type Plain SpecKubernetesNodePoolAmi
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolAmi(plain)
	return nil
}

type SpecKubernetesNodePoolContainerRuntime string

var enumValues_SpecKubernetesNodePoolContainerRuntime = []interface{}{
	"docker",
	"containerd",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolContainerRuntime) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolContainerRuntime {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolContainerRuntime, v)
	}
	*j = SpecKubernetesNodePoolContainerRuntime(v)
	return nil
}

const (
	SpecKubernetesNodePoolContainerRuntimeDocker     SpecKubernetesNodePoolContainerRuntime = "docker"
	SpecKubernetesNodePoolContainerRuntimeContainerd SpecKubernetesNodePoolContainerRuntime = "containerd"
)

type SpecKubernetesNodePoolInstanceVolumeType string

var enumValues_SpecKubernetesNodePoolInstanceVolumeType = []interface{}{
	"gp2",
	"gp3",
	"io1",
	"standard",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolInstanceVolumeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolInstanceVolumeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolInstanceVolumeType, v)
	}
	*j = SpecKubernetesNodePoolInstanceVolumeType(v)
	return nil
}

const (
	SpecKubernetesNodePoolInstanceVolumeTypeGp2      SpecKubernetesNodePoolInstanceVolumeType = "gp2"
	SpecKubernetesNodePoolInstanceVolumeTypeGp3      SpecKubernetesNodePoolInstanceVolumeType = "gp3"
	SpecKubernetesNodePoolInstanceVolumeTypeIo1      SpecKubernetesNodePoolInstanceVolumeType = "io1"
	SpecKubernetesNodePoolInstanceVolumeTypeStandard SpecKubernetesNodePoolInstanceVolumeType = "standard"
)

type SpecKubernetesNodePoolInstance struct {
	// MaxPods corresponds to the JSON schema field "maxPods".
	MaxPods *int `json:"maxPods,omitempty" yaml:"maxPods,omitempty" mapstructure:"maxPods,omitempty"`

	// If true, the nodes will be created as spot instances
	Spot *bool `json:"spot,omitempty" yaml:"spot,omitempty" mapstructure:"spot,omitempty"`

	// The instance type to use for the nodes
	Type string `json:"type" yaml:"type" mapstructure:"type"`

	// The size of the disk in GB
	VolumeSize *int `json:"volumeSize,omitempty" yaml:"volumeSize,omitempty" mapstructure:"volumeSize,omitempty"`

	// VolumeType corresponds to the JSON schema field "volumeType".
	VolumeType *SpecKubernetesNodePoolInstanceVolumeType `json:"volumeType,omitempty" yaml:"volumeType,omitempty" mapstructure:"volumeType,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolInstance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecKubernetesNodePoolInstance: required")
	}
	type Plain SpecKubernetesNodePoolInstance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolInstance(plain)
	return nil
}

type TypesKubeLabels_1 map[string]string

type SpecKubernetesNodePoolSize struct {
	// The maximum number of nodes in the node pool
	Max int `json:"max" yaml:"max" mapstructure:"max"`

	// The minimum number of nodes in the node pool
	Min int `json:"min" yaml:"min" mapstructure:"min"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolSize) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max"]; !ok || v == nil {
		return fmt.Errorf("field max in SpecKubernetesNodePoolSize: required")
	}
	if v, ok := raw["min"]; !ok || v == nil {
		return fmt.Errorf("field min in SpecKubernetesNodePoolSize: required")
	}
	type Plain SpecKubernetesNodePoolSize
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePoolSize(plain)
	return nil
}

type TypesAwsSubnetId string

type TypesKubeTaints []string

type SpecKubernetesNodePoolType string

var enumValues_SpecKubernetesNodePoolType = []interface{}{
	"eks-managed",
	"self-managed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolType, v)
	}
	*j = SpecKubernetesNodePoolType(v)
	return nil
}

const (
	SpecKubernetesNodePoolTypeEksManaged  SpecKubernetesNodePoolType = "eks-managed"
	SpecKubernetesNodePoolTypeSelfManaged SpecKubernetesNodePoolType = "self-managed"
)

type SpecKubernetesNodePool struct {
	// AdditionalFirewallRules corresponds to the JSON schema field
	// "additionalFirewallRules".
	AdditionalFirewallRules *SpecKubernetesNodePoolAdditionalFirewallRules `json:"additionalFirewallRules,omitempty" yaml:"additionalFirewallRules,omitempty" mapstructure:"additionalFirewallRules,omitempty"`

	// Ami corresponds to the JSON schema field "ami".
	Ami *SpecKubernetesNodePoolAmi `json:"ami,omitempty" yaml:"ami,omitempty" mapstructure:"ami,omitempty"`

	// This optional array defines additional target groups to attach to the instances
	// in the node pool
	AttachedTargetGroups []TypesAwsArn `json:"attachedTargetGroups,omitempty" yaml:"attachedTargetGroups,omitempty" mapstructure:"attachedTargetGroups,omitempty"`

	// The container runtime to use for the nodes
	ContainerRuntime *SpecKubernetesNodePoolContainerRuntime `json:"containerRuntime,omitempty" yaml:"containerRuntime,omitempty" mapstructure:"containerRuntime,omitempty"`

	// Instance corresponds to the JSON schema field "instance".
	Instance SpecKubernetesNodePoolInstance `json:"instance" yaml:"instance" mapstructure:"instance"`

	// Kubernetes labels that will be added to the nodes
	Labels TypesKubeLabels_1 `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// The name of the node pool
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Size corresponds to the JSON schema field "size".
	Size SpecKubernetesNodePoolSize `json:"size" yaml:"size" mapstructure:"size"`

	// This value defines the subnet IDs where the nodes will be created
	SubnetIds []TypesAwsSubnetId `json:"subnetIds,omitempty" yaml:"subnetIds,omitempty" mapstructure:"subnetIds,omitempty"`

	// AWS tags that will be added to the ASG and EC2 instances
	Tags TypesAwsTags `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Kubernetes taints that will be added to the nodes
	Taints TypesKubeTaints `json:"taints,omitempty" yaml:"taints,omitempty" mapstructure:"taints,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *SpecKubernetesNodePoolType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePool) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["instance"]; !ok || v == nil {
		return fmt.Errorf("field instance in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecKubernetesNodePool: required")
	}
	if v, ok := raw["size"]; !ok || v == nil {
		return fmt.Errorf("field size in SpecKubernetesNodePool: required")
	}
	type Plain SpecKubernetesNodePool
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetesNodePool(plain)
	return nil
}

type SpecKubernetesNodePoolsLaunchKind string

var enumValues_SpecKubernetesNodePoolsLaunchKind = []interface{}{
	"launch_configurations",
	"launch_templates",
	"both",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetesNodePoolsLaunchKind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SpecKubernetesNodePoolsLaunchKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SpecKubernetesNodePoolsLaunchKind, v)
	}
	*j = SpecKubernetesNodePoolsLaunchKind(v)
	return nil
}

const (
	SpecKubernetesNodePoolsLaunchKindLaunchConfigurations SpecKubernetesNodePoolsLaunchKind = "launch_configurations"
	SpecKubernetesNodePoolsLaunchKindLaunchTemplates      SpecKubernetesNodePoolsLaunchKind = "launch_templates"
	SpecKubernetesNodePoolsLaunchKindBoth                 SpecKubernetesNodePoolsLaunchKind = "both"
)

var enumValues_TypesKubeTolerationEffect = []interface{}{
	"NoSchedule",
	"PreferNoSchedule",
	"NoExecute",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecKubernetes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiServer"]; !ok || v == nil {
		return fmt.Errorf("field apiServer in SpecKubernetes: required")
	}
	if v, ok := raw["nodeAllowedSshPublicKey"]; !ok || v == nil {
		return fmt.Errorf("field nodeAllowedSshPublicKey in SpecKubernetes: required")
	}
	if v, ok := raw["nodePools"]; !ok || v == nil {
		return fmt.Errorf("field nodePools in SpecKubernetes: required")
	}
	if v, ok := raw["nodePoolsLaunchKind"]; !ok || v == nil {
		return fmt.Errorf("field nodePoolsLaunchKind in SpecKubernetes: required")
	}
	type Plain SpecKubernetes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecKubernetes(plain)
	return nil
}

type SpecPluginsHelmReleasesElemSetElem struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Value corresponds to the JSON schema field "value".
	Value string `json:"value" yaml:"value" mapstructure:"value"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecPluginsHelmReleasesElemSetElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in SpecPluginsHelmReleasesElemSetElem: required")
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value in SpecPluginsHelmReleasesElemSetElem: required")
	}
	type Plain SpecPluginsHelmReleasesElemSetElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecPluginsHelmReleasesElemSetElem(plain)
	return nil
}

type SpecPluginsHelmReleases []struct {
	// Chart corresponds to the JSON schema field "chart".
	Chart string `json:"chart" yaml:"chart" mapstructure:"chart"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace string `json:"namespace" yaml:"namespace" mapstructure:"namespace"`

	// Set corresponds to the JSON schema field "set".
	Set []SpecPluginsHelmReleasesElemSetElem `json:"set,omitempty" yaml:"set,omitempty" mapstructure:"set,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type SpecPluginsHelmRepositories []struct {
	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type SpecPluginsHelm struct {
	// Releases corresponds to the JSON schema field "releases".
	Releases SpecPluginsHelmReleases `json:"releases,omitempty" yaml:"releases,omitempty" mapstructure:"releases,omitempty"`

	// Repositories corresponds to the JSON schema field "repositories".
	Repositories SpecPluginsHelmRepositories `json:"repositories,omitempty" yaml:"repositories,omitempty" mapstructure:"repositories,omitempty"`
}

type SpecPluginsKustomize []struct {
	// Folder corresponds to the JSON schema field "folder".
	Folder string `json:"folder" yaml:"folder" mapstructure:"folder"`

	// Name corresponds to the JSON schema field "name".
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

type SpecPlugins struct {
	// Helm corresponds to the JSON schema field "helm".
	Helm *SpecPluginsHelm `json:"helm,omitempty" yaml:"helm,omitempty" mapstructure:"helm,omitempty"`

	// Kustomize corresponds to the JSON schema field "kustomize".
	Kustomize SpecPluginsKustomize `json:"kustomize,omitempty" yaml:"kustomize,omitempty" mapstructure:"kustomize,omitempty"`
}

type TypesAwsS3KeyPrefix string

type SpecToolsConfigurationTerraformStateS3 struct {
	// This value defines which bucket will be used to store all the states
	BucketName TypesAwsS3BucketName `json:"bucketName" yaml:"bucketName" mapstructure:"bucketName"`

	// This value defines which folder will be used to store all the states inside the
	// bucket
	KeyPrefix TypesAwsS3KeyPrefix `json:"keyPrefix" yaml:"keyPrefix" mapstructure:"keyPrefix"`

	// This value defines in which region the bucket is located
	Region TypesAwsRegion `json:"region" yaml:"region" mapstructure:"region"`

	// This value defines if the region of the bucket should be validated or not by
	// Terraform, useful when using a bucket in a recently added region
	SkipRegionValidation *bool `json:"skipRegionValidation,omitempty" yaml:"skipRegionValidation,omitempty" mapstructure:"skipRegionValidation,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraformStateS3) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bucketName"]; !ok || v == nil {
		return fmt.Errorf("field bucketName in SpecToolsConfigurationTerraformStateS3: required")
	}
	if v, ok := raw["keyPrefix"]; !ok || v == nil {
		return fmt.Errorf("field keyPrefix in SpecToolsConfigurationTerraformStateS3: required")
	}
	if v, ok := raw["region"]; !ok || v == nil {
		return fmt.Errorf("field region in SpecToolsConfigurationTerraformStateS3: required")
	}
	type Plain SpecToolsConfigurationTerraformStateS3
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraformStateS3(plain)
	return nil
}

type SpecToolsConfigurationTerraformState struct {
	// S3 corresponds to the JSON schema field "s3".
	S3 SpecToolsConfigurationTerraformStateS3 `json:"s3" yaml:"s3" mapstructure:"s3"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraformState) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["s3"]; !ok || v == nil {
		return fmt.Errorf("field s3 in SpecToolsConfigurationTerraformState: required")
	}
	type Plain SpecToolsConfigurationTerraformState
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraformState(plain)
	return nil
}

type SpecToolsConfigurationTerraform struct {
	// State corresponds to the JSON schema field "state".
	State SpecToolsConfigurationTerraformState `json:"state" yaml:"state" mapstructure:"state"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfigurationTerraform) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["state"]; !ok || v == nil {
		return fmt.Errorf("field state in SpecToolsConfigurationTerraform: required")
	}
	type Plain SpecToolsConfigurationTerraform
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfigurationTerraform(plain)
	return nil
}

type SpecToolsConfiguration struct {
	// Terraform corresponds to the JSON schema field "terraform".
	Terraform SpecToolsConfigurationTerraform `json:"terraform" yaml:"terraform" mapstructure:"terraform"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecToolsConfiguration) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["terraform"]; !ok || v == nil {
		return fmt.Errorf("field terraform in SpecToolsConfiguration: required")
	}
	type Plain SpecToolsConfiguration
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecToolsConfiguration(plain)
	return nil
}

type TypesKubeTolerationEffect string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Spec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["distribution"]; !ok || v == nil {
		return fmt.Errorf("field distribution in Spec: required")
	}
	if v, ok := raw["distributionVersion"]; !ok || v == nil {
		return fmt.Errorf("field distributionVersion in Spec: required")
	}
	if v, ok := raw["kubernetes"]; !ok || v == nil {
		return fmt.Errorf("field kubernetes in Spec: required")
	}
	if v, ok := raw["region"]; !ok || v == nil {
		return fmt.Errorf("field region in Spec: required")
	}
	if v, ok := raw["toolsConfiguration"]; !ok || v == nil {
		return fmt.Errorf("field toolsConfiguration in Spec: required")
	}
	type Plain Spec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.DistributionVersion) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "distributionVersion", 1)
	}
	*j = Spec(plain)
	return nil
}

type TypesAwsSshPubKey string

type TypesEnvRef string

type TypesFileRef string

type TypesIpAddress string

type TypesSemVer string

type TypesSshPubKey string

type TypesUri string

// UnmarshalJSON implements json.Unmarshaler.
func (j *SpecDistributionCommonProvider) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in SpecDistributionCommonProvider: required")
	}
	type Plain SpecDistributionCommonProvider
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SpecDistributionCommonProvider(plain)
	return nil
}

var enumValues_EksclusterKfdV1Alpha2Kind = []interface{}{
	"EKSCluster",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EksclusterKfdV1Alpha2Kind) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EksclusterKfdV1Alpha2Kind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EksclusterKfdV1Alpha2Kind, v)
	}
	*j = EksclusterKfdV1Alpha2Kind(v)
	return nil
}

type TypesKubeNodeSelector map[string]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Metadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in Metadata: required")
	}
	type Plain Metadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 56 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 56)
	}
	*j = Metadata(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EksclusterKfdV1Alpha2) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["apiVersion"]; !ok || v == nil {
		return fmt.Errorf("field apiVersion in EksclusterKfdV1Alpha2: required")
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		return fmt.Errorf("field kind in EksclusterKfdV1Alpha2: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in EksclusterKfdV1Alpha2: required")
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		return fmt.Errorf("field spec in EksclusterKfdV1Alpha2: required")
	}
	type Plain EksclusterKfdV1Alpha2
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EksclusterKfdV1Alpha2(plain)
	return nil
}
